"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/components/LivePreview.tsx":
/*!****************************************!*\
  !*** ./src/components/LivePreview.tsx ***!
  \****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/debounce */ \"(app-pages-browser)/./node_modules/lodash/debounce.js\");\n/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\nconst LivePreview = (param)=>{\n    let { pages, currentPage, onPageChange, onFileUpload } = param;\n    _s();\n    const [localPage, setLocalPage] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(currentPage);\n    const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [isDragOver, setIsDragOver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [lastValidHTML, setLastValidHTML] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const iframeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const dropZoneRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Clean HTML code\n    const cleanCode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LivePreview.useCallback[cleanCode]\": (htmlCode, pageName)=>{\n            try {\n                let cleaned = htmlCode.replace(/^[\\s\\S]*?(<!DOCTYPE html[\\s\\S]*?<\\/html>)/i, '$1').replace(/```html\\n|```/g, '').replace(/<!--[\\s\\S]*?-->/g, '').trim();\n                if (!cleaned) throw new Error('HTML content is empty after cleaning');\n                if (!cleaned.startsWith('<!DOCTYPE html>')) cleaned = '<!DOCTYPE html>\\n' + cleaned;\n                if (!cleaned.includes('<html')) cleaned = '<!DOCTYPE html>\\n<html lang=\"en\">\\n' + cleaned + '\\n</html>';\n                if (!cleaned.includes('<head>')) {\n                    cleaned = cleaned.replace('<html', '<html lang=\"en\">\\n<head>\\n<meta charset=\"UTF-8\">\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n</head>\\n');\n                }\n                if (!cleaned.includes('<body>')) {\n                    cleaned = cleaned.replace('</head>', '</head>\\n<body>\\n') + '\\n</body>';\n                }\n                if (!cleaned.endsWith('</html>')) cleaned = cleaned + '\\n</html>';\n                return cleaned;\n            } catch (err) {\n                console.error('Error in cleanCode:', err);\n                return lastValidHTML || '\\n        <!DOCTYPE html>\\n        <html lang=\"en\">\\n          <head>\\n            <meta charset=\"UTF-8\">\\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\\n          </head>\\n          <body>\\n            <h1>Erreur : Contenu HTML invalide</h1>\\n          </body>\\n        </html>\\n      ';\n            }\n        }\n    }[\"LivePreview.useCallback[cleanCode]\"], [\n        currentPage,\n        lastValidHTML\n    ]);\n    // Inject drag-and-drop, text editing, and control frame script\n    const injectDragDropScript = ()=>\"\\n    <script>\\n      document.addEventListener('DOMContentLoaded', () => {\\n        const editableElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, div, section, article, aside, figure, img, button');\\n        let elementCounter = editableElements.length;\\n\\n        editableElements.forEach((el, index) => {\\n          const isGoogleMapSection = el.tagName === 'SECTION' && el.querySelector('#map');\\n          if ((el.textContent && el.textContent.trim()) || el.tagName === 'IMG' || el.tagName === 'BUTTON' || isGoogleMapSection) {\\n            el.setAttribute('draggable', 'true');\\n            el.setAttribute('data-drag-id', 'drag-' + index);\\n            el.style.position = 'relative';\\n            el.style.cursor = 'move';\\n            el.style.display = isGoogleMapSection ? 'block' : (el.tagName === 'IMG' ? 'inline-block' : el.style.display || 'block');\\n            if (isGoogleMapSection) {\\n              const mapDiv = el.querySelector('#map');\\n              if (mapDiv) {\\n                mapDiv.style.width = mapDiv.style.width || '100%';\\n                mapDiv.style.height = mapDiv.style.height || '400px';\\n              }\\n            }\\n\\n            // Add click handler to show selection frame and toolbar\\n            el.addEventListener('click', (e) => {\\n              e.preventDefault();\\n              e.stopPropagation();\\n\\n              // Remove existing frame and toolbar\\n              const existingFrame = document.querySelector('.selection-frame');\\n              if (existingFrame) existingFrame.remove();\\n              const existingToolbar = document.querySelector('.control-toolbar');\\n              if (existingToolbar) existingToolbar.remove();\\n\\n              // Create selection frame\\n              const rect = el.getBoundingClientRect();\\n              const frame = document.createElement('div');\\n              frame.className = 'selection-frame';\\n              frame.style.position = 'absolute';\\n              frame.style.top = (rect.top - 2 + window.scrollY) + 'px';\\n              frame.style.left = (rect.left - 2 + window.scrollX) + 'px';\\n              frame.style.width = (rect.width + 4) + 'px';\\n              frame.style.height = (rect.height + 4) + 'px';\\n              frame.style.border = '2px solid #007bff';\\n              frame.style.zIndex = '999';\\n              frame.setAttribute('data-target-id', 'drag-' + index);\\n              document.body.appendChild(frame);\\n\\n              // Create toolbar\\n              const toolbar = document.createElement('div');\\n              toolbar.className = 'control-toolbar';\\n              toolbar.style.position = 'absolute';\\n              toolbar.style.top = (rect.top - 40 + window.scrollY) + 'px';\\n              toolbar.style.left = (rect.left + rect.width / 2 - 100 + window.scrollX) + 'px';\\n              toolbar.style.background = '#fff';\\n              toolbar.style.border = '1px solid #ddd';\\n              toolbar.style.borderRadius = '8px';\\n              toolbar.style.padding = '4px';\\n              toolbar.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';\\n              toolbar.style.zIndex = '1000';\\n              toolbar.style.display = 'flex';\\n              toolbar.style.gap = '4px';\\n\\n              const icons = [\\n                { title: 'Edit', icon: '✏️' },\\n                { title: 'Lock', icon: '\\uD83D\\uDD12' },\\n                { title: 'Duplicate', icon: '\\uD83D\\uDCCB' },\\n                { title: 'Delete', icon: '\\uD83D\\uDDD1️' },\\n                { title: 'More', icon: '⋯' },\\n                { title: 'Add Image', icon: '\\uD83D\\uDDBC️' }\\n              ].map(item => {\\n                const btn = document.createElement('button');\\n                btn.innerHTML = item.icon;\\n                btn.title = item.title;\\n                btn.style.border = 'none';\\n                btn.style.background = 'none';\\n                btn.style.cursor = 'pointer';\\n                btn.style.fontSize = '16px';\\n                btn.style.padding = '4px';\\n                btn.addEventListener('click', (e) => {\\n                  e.stopPropagation();\\n                  if (item.title === 'Delete') {\\n                    el.remove();\\n                    frame.remove();\\n                    toolbar.remove();\\n                  } else if (item.title === 'Duplicate') {\\n                    const clone = el.cloneNode(true);\\n                    elementCounter++;\\n                    clone.setAttribute('data-drag-id', 'drag-' + elementCounter);\\n                    el.parentNode.insertBefore(clone, el.nextSibling);\\n                    frame.remove();\\n                    toolbar.remove();\\n                  } else if (item.title === 'Add Image') {\\n                    window.parent.postMessage({ type: 'upload-image' }, '*');\\n                  }\\n                  const newHTML = document.documentElement.outerHTML;\\n                  window.parent.postMessage({ type: 'update-html', html: newHTML }, '*');\\n                });\\n                return btn;\\n              });\\n\\n              icons.forEach(btn => toolbar.appendChild(btn));\\n              document.body.appendChild(toolbar);\\n\\n              // Hide frame and toolbar when clicking outside\\n              document.addEventListener('click', function hideFrame(e) {\\n                if (!frame.contains(e.target) && !el.contains(e.target) && !toolbar.contains(e.target)) {\\n                  frame.remove();\\n                  toolbar.remove();\\n                  document.removeEventListener('click', hideFrame);\\n                }\\n              }, { once: true });\\n            });\\n          }\\n        });\\n\\n        let draggedElement = null;\\n        let dropTarget = null;\\n        let isDragging = false;\\n        let isResizing = false;\\n        let resizeTarget = null;\\n        let startX, startY, startWidth, startHeight;\\n        let resizeEdge = '';\\n\\n        // Drag-and-drop functionality\\n        const handleDragStart = (e) => {\\n          const target = e.target.closest('[draggable=\\\"true\\\"]');\\n          if (target && !isResizing && ((target.textContent && target.textContent.trim()) || target.tagName === 'IMG' || target.tagName === 'BUTTON' || (target.tagName === 'SECTION' && target.querySelector('#map')))) {\\n            draggedElement = target;\\n            isDragging = true;\\n            target.classList.add('dragging');\\n            e.dataTransfer.effectAllowed = 'move';\\n            const existingFrame = document.querySelector('.selection-frame');\\n            if (existingFrame) existingFrame.remove();\\n            const existingToolbar = document.querySelector('.control-toolbar');\\n            if (existingToolbar) existingToolbar.remove();\\n          }\\n        };\\n\\n        const handleDragOver = (e) => {\\n          e.preventDefault();\\n          const target = e.target.closest('[draggable=\\\"true\\\"]');\\n          if (draggedElement && target !== draggedElement && ((target.textContent && target.textContent.trim()) || target.tagName === 'IMG' || target.tagName === 'BUTTON' || (target.tagName === 'SECTION' && target.querySelector('#map')))) {\\n            dropTarget = target;\\n            target.classList.add('drag-over');\\n          }\\n        };\\n\\n        const handleDragLeave = (e) => {\\n          const target = e.target.closest('[draggable=\\\"true\\\"]');\\n          if (target) {\\n            target.classList.remove('drag-over');\\n            dropTarget = null;\\n          }\\n        };\\n\\n        const handleDrop = (e) => {\\n          e.preventDefault();\\n          const target = dropTarget;\\n          if (draggedElement && target && draggedElement !== target && ((draggedElement.textContent && draggedElement.textContent.trim()) || draggedElement.tagName === 'IMG' || draggedElement.tagName === 'BUTTON' || (draggedElement.tagName === 'SECTION' && draggedElement.querySelector('#map')))) {\\n            const parent = target.parentElement;\\n            if (parent) {\\n              const isImageDrag = draggedElement.tagName === 'IMG';\\n              const isImageTarget = target.tagName === 'IMG';\\n              const isButtonDrag = draggedElement.tagName === 'BUTTON';\\n              const isButtonTarget = target.tagName === 'BUTTON';\\n              const isGoogleMapSectionDrag = draggedElement.tagName === 'SECTION' && draggedElement.querySelector('#map');\\n              const isGoogleMapSectionTarget = target.tagName === 'SECTION' && target.querySelector('#map');\\n\\n              if ((isImageDrag && isImageTarget) || (isButtonDrag && isButtonTarget) || (isGoogleMapSectionDrag && isGoogleMapSectionTarget)) {\\n                const tempHTML = draggedElement.innerHTML;\\n                const tempWidth = draggedElement.style.width;\\n                const tempHeight = draggedElement.style.height;\\n                draggedElement.innerHTML = target.innerHTML;\\n                draggedElement.style.width = target.style.width;\\n                draggedElement.style.height = target.style.height;\\n                target.innerHTML = tempHTML;\\n                target.style.width = tempWidth;\\n                target.style.height = tempHeight;\\n\\n                if (isGoogleMapSectionDrag || isGoogleMapSectionTarget) {\\n                  [draggedElement, target].forEach(section => {\\n                    const mapDiv = section.querySelector('#map');\\n                    if (mapDiv) {\\n                      const script = section.querySelector('script:not([src])');\\n                      if (script) eval(script.textContent);\\n                    }\\n                  });\\n                }\\n              } else {\\n                parent.insertBefore(draggedElement, target);\\n              }\\n              draggedElement.classList.remove('dragging');\\n              target.classList.remove('drag-over');\\n              draggedElement = null;\\n              dropTarget = null;\\n\\n              const newHTML = document.documentElement.outerHTML;\\n              window.parent.postMessage({ type: 'update-html', html: newHTML }, '*');\\n            }\\n          }\\n        };\\n\\n        const handleDragEnd = () => {\\n          if (draggedElement) {\\n            draggedElement.classList.remove('dragging');\\n            draggedElement = null;\\n          }\\n          if (dropTarget) {\\n            dropTarget.classList.remove('drag-over');\\n            dropTarget = null;\\n          }\\n          isDragging = false;\\n        };\\n\\n        // Attach drag-and-drop event listeners\\n        document.addEventListener('dragstart', handleDragStart);\\n        document.addEventListener('dragover', handleDragOver);\\n        document.addEventListener('dragleave', handleDragLeave);\\n        document.addEventListener('drop', handleDrop);\\n        document.addEventListener('dragend', handleDragEnd);\\n\\n        // Text editing for all text-containing elements\\n        const textElements = document.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, button');\\n        textElements.forEach(el => {\\n          if (el.textContent && el.textContent.trim()) {\\n            el.style.overflowWrap = el.style.overflowWrap || 'break-word';\\n            el.style.wordBreak = el.style.wordBreak || 'break-word';\\n            el.style.whiteSpace = el.style.whiteSpace || 'normal';\\n\\n            el.addEventListener('click', (e) => {\\n              if (el.classList.contains('editing')) return;\\n              el.classList.add('editing');\\n\\n              const computedStyle = window.getComputedStyle(el);\\n              const originalText = el.textContent;\\n\\n              const textarea = document.createElement('textarea');\\n              textarea.value = originalText;\\n\\n              textarea.style.width = computedStyle.width;\\n              textarea.style.maxWidth = computedStyle.maxWidth === 'none' ? computedStyle.width : computedStyle.maxWidth;\\n              textarea.style.height = 'auto';\\n              textarea.style.minHeight = computedStyle.height;\\n              textarea.style.maxHeight = computedStyle.maxHeight === 'none' ? 'none' : computedStyle.maxHeight;\\n              textarea.style.padding = computedStyle.padding;\\n              textarea.style.margin = computedStyle.margin;\\n              textarea.style.border = '1px solid #ccc';\\n              textarea.style.borderRadius = computedStyle.borderRadius;\\n              textarea.style.fontFamily = computedStyle.fontFamily;\\n              textarea.style.fontSize = computedStyle.fontSize;\\n              textarea.style.fontWeight = computedStyle.fontWeight;\\n              textarea.style.color = computedStyle.color;\\n              textarea.style.backgroundColor = computedStyle.backgroundColor;\\n              textarea.style.lineHeight = computedStyle.lineHeight;\\n              textarea.style.textAlign = computedStyle.textAlign;\\n              textarea.style.boxSizing = 'border-box';\\n              textarea.style.resize = 'vertical';\\n              textarea.style.overflowWrap = 'break-word';\\n              textarea.style.wordBreak = 'break-word';\\n              textarea.style.whiteSpace = 'normal';\\n              textarea.style.overflow = computedStyle.overflow === 'visible' ? 'auto' : computedStyle.overflow;\\n\\n              el.textContent = '';\\n              el.appendChild(textarea);\\n              textarea.focus();\\n\\n              textarea.style.height = 'auto';\\n              textarea.style.height = `${textarea.scrollHeight}px`;\\n\\n              textarea.addEventListener('input', () => {\\n                textarea.style.height = 'auto';\\n                textarea.style.height = `${textarea.scrollHeight}px`;\\n              });\\n\\n              textarea.addEventListener('blur', () => {\\n                const newText = textarea.value || originalText;\\n                while (el.firstChild) {\\n                  el.removeChild(el.firstChild);\\n                }\\n                el.textContent = newText;\\n                el.classList.remove('editing');\\n\\n                el.style.overflowWrap = 'break-word';\\n                el.style.wordBreak = 'break-word';\\n                el.style.whiteSpace = 'normal';\\n\\n                const newHTML = document.documentElement.outerHTML;\\n                window.parent.postMessage({ type: 'update-html', html: newHTML }, '*');\\n              });\\n\\n              textarea.addEventListener('keypress', (e) => {\\n                if (e.key === 'Enter' && !e.shiftKey) {\\n                  e.preventDefault();\\n                  textarea.blur();\\n                }\\n              });\\n            });\\n          }\\n        });\\n\\n        // Helper function to determine if the mouse is near an edge\\n        const isNearEdge = (el, clientX, clientY) => {\\n          const rect = el.getBoundingClientRect();\\n          const edgeThreshold = 10;\\n          const nearRight = Math.abs(clientX - rect.right) < edgeThreshold;\\n          const nearBottom = Math.abs(clientY - rect.bottom) < edgeThreshold;\\n          const nearLeft = Math.abs(clientX - rect.left) < edgeThreshold;\\n          const nearTop = Math.abs(clientY - rect.top) < edgeThreshold;\\n\\n          if (nearRight && nearBottom) return 'bottom-right';\\n          if (nearLeft && nearBottom) return 'bottom-left';\\n          if (nearRight && nearTop) return 'top-right';\\n          if (nearLeft && nearTop) return 'top-left';\\n          if (nearRight) return 'right';\\n          if (nearLeft) return 'left';\\n          if (nearBottom) return 'bottom';\\n          if (nearTop) return 'top';\\n          return '';\\n        };\\n\\n        // Edge-based resizing on the selection frame\\n        document.addEventListener('mousemove', (e) => {\\n          if (isResizing) return;\\n\\n          const frame = document.querySelector('.selection-frame');\\n          if (frame) {\\n            const edge = isNearEdge(frame, e.clientX, e.clientY);\\n            if (edge === 'bottom-right' || edge === 'top-left') {\\n              frame.style.cursor = 'se-resize';\\n            } else if (edge === 'bottom-left' || edge === 'top-right') {\\n              frame.style.cursor = 'sw-resize';\\n            } else if (edge === 'left' || edge === 'right') {\\n              frame.style.cursor = 'ew-resize';\\n            } else if (edge === 'top' || edge === 'bottom') {\\n              frame.style.cursor = 'ns-resize';\\n            } else {\\n              frame.style.cursor = 'default';\\n            }\\n          }\\n        });\\n\\n        document.addEventListener('mousedown', (e) => {\\n          const frame = document.querySelector('.selection-frame');\\n          const target = document.querySelector('[data-drag-id=\\\"' + (frame?.getAttribute('data-target-id') || '') + '\\\"]');\\n          if (frame && target) {\\n            const edge = isNearEdge(frame, e.clientX, e.clientY);\\n            if (edge) {\\n              isResizing = true;\\n              resizeTarget = target;\\n              resizeEdge = edge;\\n              startX = e.clientX;\\n              startY = e.clientY;\\n              startWidth = parseInt(getComputedStyle(target).width) || target.offsetWidth;\\n              startHeight = parseInt(getComputedStyle(target).height) || target.offsetHeight;\\n              e.preventDefault();\\n            }\\n          }\\n        });\\n\\n        document.addEventListener('mousemove', (e) => {\\n          if (!isResizing || !resizeTarget) return;\\n\\n          const dx = e.clientX - startX;\\n          const dy = e.clientY - startY;\\n          let newWidth = startWidth;\\n          let newHeight = startHeight;\\n\\n          if (resizeEdge.includes('right')) {\\n            newWidth = Math.max(50, startWidth + dx);\\n          } else if (resizeEdge.includes('left')) {\\n            newWidth = Math.max(50, startWidth - dx);\\n            resizeTarget.style.left = (parseInt(getComputedStyle(resizeTarget).left) || 0) + (startWidth - newWidth) + 'px';\\n          }\\n          if (resizeEdge.includes('bottom')) {\\n            newHeight = Math.max(50, startHeight + dy);\\n          } else if (resizeEdge.includes('top')) {\\n            newHeight = Math.max(50, startHeight - dy);\\n            resizeTarget.style.top = (parseInt(getComputedStyle(resizeTarget).top) || 0) + (startHeight - newHeight) + 'px';\\n          }\\n\\n          resizeTarget.style.width = `${newWidth}px`;\\n          resizeTarget.style.height = `${newHeight}px`;\\n\\n          const mapDiv = resizeTarget.querySelector('#map');\\n          if (mapDiv) {\\n            mapDiv.style.width = `${newWidth}px`;\\n            mapDiv.style.height = `${newHeight - 50}px`;\\n            if (typeof google !== 'undefined' && google.maps) {\\n              google.maps.event.trigger(mapDiv.__gmap__, 'resize');\\n            }\\n          }\\n\\n          // Update the frame size\\n          const frame = document.querySelector('.selection-frame');\\n          if (frame) {\\n            frame.style.width = (newWidth + 4) + 'px';\\n            frame.style.height = (newHeight + 4) + 'px';\\n            frame.style.left = (resizeTarget.getBoundingClientRect().left - 2 + window.scrollX) + 'px';\\n            frame.style.top = (resizeTarget.getBoundingClientRect().top - 2 + window.scrollY) + 'px';\\n          }\\n        });\\n\\n        document.addEventListener('mouseup', () => {\\n          if (isResizing) {\\n            isResizing = false;\\n            const newHTML = document.documentElement.outerHTML;\\n            window.parent.postMessage({ type: 'update-html', html: newHTML }, '*');\\n            resizeTarget.style.cursor = 'move';\\n            resizeTarget = null;\\n            resizeEdge = '';\\n          }\\n        });\\n      });\\n    </script>\\n    <style>\\n      .dragging {\\n        opacity: 0.5;\\n        transform: scale(1.2);\\n        transition: opacity 0.3s, transform 0.2s ease-in-out;\\n        border: 2px dashed #007bff;\\n      }\\n      .drag-over {\\n        background: #a5d6a7;\\n        border: 2px dashed #4caf50;\\n      }\\n      [draggable=\\\"true\\\"] {\\n        padding: 0.5rem;\\n        margin: 0.5rem;\\n        cursor: grab;\\n      }\\n      [draggable=\\\"true\\\"].dragging {\\n        cursor: grabbing;\\n      }\\n      .editing {\\n        border: 1px dashed #007bff;\\n        padding: 5px;\\n      }\\n      img, div, section, article, aside, figure, button {\\n        min-width: 50px;\\n        min-height: 50px;\\n      }\\n      section:has(#map) {\\n        border: 1px solid #ddd;\\n        border-radius: 8px;\\n        padding: 10px;\\n        box-shadow: 0 2px 5px rgba(0,0,0,0.1);\\n      }\\n      .control-toolbar button:hover {\\n        background: #f0f0f0;\\n        border-radius: 4px;\\n      }\\n      .selection-frame {\\n        pointer-events: auto;\\n        box-sizing: border-box;\\n      }\\n    </style>\\n  \";\n    // Process HTML with navigation and drag-and-drop scripts\n    const processHTML = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LivePreview.useCallback[processHTML]\": (html, pageList)=>{\n            try {\n                const parser = new DOMParser();\n                const doc = parser.parseFromString(html, 'text/html');\n                if (!doc.querySelector('script[data-navigation-handler]')) {\n                    const script = doc.createElement('script');\n                    script.setAttribute('data-navigation-handler', 'true');\n                    script.textContent = \"\\n          document.addEventListener('DOMContentLoaded', () => {\\n            document.querySelectorAll('a[href$=\\\".html\\\"]').forEach(link => {\\n              link.addEventListener('click', e => {\\n                e.preventDefault();\\n                const href = link.getAttribute('href');\\n                window.parent.postMessage({ type: 'navigation', href }, '*');\\n              });\\n            });\\n          });\\n        \";\n                    doc.body.appendChild(script);\n                }\n                if (!doc.querySelector('script[data-drag-drop-handler]')) {\n                    const dragDropScript = doc.createElement('script');\n                    dragDropScript.setAttribute('data-drag-drop-handler', 'true');\n                    dragDropScript.textContent = injectDragDropScript();\n                    doc.body.appendChild(dragDropScript);\n                }\n                const nav = doc.querySelector('nav');\n                if (nav && pageList.length > 0) {\n                    const theme = nav.getAttribute('data-theme') || 'digital';\n                    nav.outerHTML = getNavBar(pageList, currentPage, theme);\n                }\n                return '<!DOCTYPE html>' + doc.documentElement.outerHTML;\n            } catch (err) {\n                console.error('Error processing HTML:', err);\n                throw new Error('Invalid HTML content');\n            }\n        }\n    }[\"LivePreview.useCallback[processHTML]\"], [\n        currentPage\n    ]);\n    // Navigation bar generator\n    function getNavBar(pages, currentPage, theme) {\n        const colors = {\n            navBg: 'rgba(42, 42, 42, 0.8)',\n            navLink: '#e0e0e0',\n            navActive: '#bb86fc'\n        };\n        return '\\n      <nav style=\"position: sticky; top: 0; background: '.concat(colors.navBg, '; padding: 1rem 2rem; text-align: center; box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); z-index: 1000;\">\\n        ').concat(pages.map((page)=>{\n            const pageName = page.replace('.html', '');\n            const isActive = page === currentPage;\n            const activeStyle = isActive ? \"color: \".concat(colors.navActive, \"; border-bottom: 2px solid \").concat(colors.navActive, \";\") : '';\n            return '<a href=\"'.concat(page, '\" style=\"color: ').concat(colors.navLink, \"; text-decoration: none; margin: 0 1.5rem; font-weight: 600; \").concat(activeStyle, '\">').concat(pageName, \"</a>\");\n        }).join(''), \"\\n      </nav>\\n    \");\n    }\n    // Handle drag-and-drop events for file uploads\n    const handleDragOver = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LivePreview.useCallback[handleDragOver]\": (e)=>{\n            e.preventDefault();\n            e.stopPropagation();\n            setIsDragOver(true);\n        }\n    }[\"LivePreview.useCallback[handleDragOver]\"], []);\n    const handleDragLeave = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LivePreview.useCallback[handleDragLeave]\": (e)=>{\n            e.preventDefault();\n            e.stopPropagation();\n            setIsDragOver(false);\n        }\n    }[\"LivePreview.useCallback[handleDragLeave]\"], []);\n    const handleDrop = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"LivePreview.useCallback[handleDrop]\": async (e)=>{\n            e.preventDefault();\n            e.stopPropagation();\n            setIsDragOver(false);\n            const files = e.dataTransfer.files;\n            if (files.length > 0) {\n                const file = files[0];\n                const reader = new FileReader();\n                reader.onload = ({\n                    \"LivePreview.useCallback[handleDrop]\": (event)=>{\n                        if (event.target && typeof event.target.result === 'string') {\n                            if (onFileUpload) onFileUpload(file, event.target.result);\n                        }\n                    }\n                })[\"LivePreview.useCallback[handleDrop]\"];\n                reader.readAsText(file);\n            }\n        }\n    }[\"LivePreview.useCallback[handleDrop]\"], [\n        onFileUpload\n    ]);\n    // Update iframe content with debouncing\n    const updateIframe = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"LivePreview.useMemo[updateIframe]\": ()=>lodash_debounce__WEBPACK_IMPORTED_MODULE_2___default()({\n                \"LivePreview.useMemo[updateIframe]\": ()=>{\n                    const iframe = iframeRef.current;\n                    if (!iframe || !pages[currentPage]) {\n                        setError('Page not found or iframe unavailable');\n                        setIsLoading(false);\n                        if (iframe && lastValidHTML) iframe.srcdoc = lastValidHTML;\n                        return;\n                    }\n                    setIsLoading(true);\n                    setError(null);\n                    try {\n                        const cleanedHTML = cleanCode(pages[currentPage], currentPage);\n                        const pageList = Object.keys(pages);\n                        const processedHTML = processHTML(cleanedHTML + injectDragDropScript(), pageList);\n                        iframe.srcdoc = processedHTML;\n                        setLastValidHTML(processedHTML);\n                    } catch (err) {\n                        setError('Failed to load page content: ' + (err instanceof Error ? err.message : String(err)));\n                        setIsLoading(false);\n                        if (iframe && lastValidHTML) iframe.srcdoc = lastValidHTML;\n                    }\n                }\n            }[\"LivePreview.useMemo[updateIframe]\"], 300)\n    }[\"LivePreview.useMemo[updateIframe]\"], [\n        currentPage,\n        pages,\n        processHTML,\n        cleanCode,\n        lastValidHTML\n    ]);\n    // Handle iframe updates and messages\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LivePreview.useEffect\": ()=>{\n            updateIframe();\n            const iframe = iframeRef.current;\n            if (!iframe) return;\n            const handleLoad = {\n                \"LivePreview.useEffect.handleLoad\": ()=>setIsLoading(false)\n            }[\"LivePreview.useEffect.handleLoad\"];\n            iframe.addEventListener('load', handleLoad);\n            const handleMessage = {\n                \"LivePreview.useEffect.handleMessage\": async (event)=>{\n                    var _event_data, _event_data1, _event_data2;\n                    if (event.origin !== 'http://localhost:3000') return; // Security check\n                    if (((_event_data = event.data) === null || _event_data === void 0 ? void 0 : _event_data.type) === 'navigation' && typeof event.data.href === 'string') {\n                        if (pages[event.data.href]) {\n                            setLocalPage(event.data.href);\n                            onPageChange === null || onPageChange === void 0 ? void 0 : onPageChange(event.data.href);\n                        } else {\n                            setError('Page \"'.concat(event.data.href, '\" not found'));\n                            const fallbackPage = Object.keys(pages).filter({\n                                \"LivePreview.useEffect.handleMessage\": (page)=>page.endsWith('.html')\n                            }[\"LivePreview.useEffect.handleMessage\"])[0] || '';\n                            setLocalPage(fallbackPage);\n                            onPageChange === null || onPageChange === void 0 ? void 0 : onPageChange(fallbackPage);\n                        }\n                    } else if (((_event_data1 = event.data) === null || _event_data1 === void 0 ? void 0 : _event_data1.type) === 'file-drop') {\n                        if (onFileUpload) {\n                            const fileContent = event.data.fileContent;\n                            const fileName = event.data.fileName;\n                            if (typeof fileContent === 'string' && typeof fileName === 'string') {\n                                const file = new File([\n                                    fileContent\n                                ], fileName, {\n                                    type: 'text/html'\n                                });\n                                onFileUpload(file, fileContent);\n                            }\n                        }\n                    } else if (((_event_data2 = event.data) === null || _event_data2 === void 0 ? void 0 : _event_data2.type) === 'update-html') {\n                        const newHTML = event.data.html;\n                        try {\n                            const response = await fetch('http://localhost:5000/api/save-page', {\n                                method: 'POST',\n                                headers: {\n                                    'Content-Type': 'application/json'\n                                },\n                                body: JSON.stringify({\n                                    pagePath: currentPage,\n                                    code: newHTML\n                                })\n                            });\n                            if (!response.ok) {\n                                throw new Error(\"HTTP error! status: \".concat(response.status));\n                            }\n                            const result = await response.json();\n                            pages[currentPage] = newHTML; // Update local state\n                            updateIframe(); // Refresh iframe\n                        } catch (err) {\n                            setError(\"Failed to save updated HTML: \".concat(err instanceof Error ? err.message : String(err)));\n                        }\n                    }\n                }\n            }[\"LivePreview.useEffect.handleMessage\"];\n            window.addEventListener('message', handleMessage);\n            return ({\n                \"LivePreview.useEffect\": ()=>{\n                    iframe.removeEventListener('load', handleLoad);\n                    updateIframe.cancel();\n                    window.removeEventListener('message', handleMessage);\n                }\n            })[\"LivePreview.useEffect\"];\n        }\n    }[\"LivePreview.useEffect\"], [\n        currentPage,\n        pages,\n        updateIframe,\n        onFileUpload\n    ]);\n    // Validate initial page\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"LivePreview.useEffect\": ()=>{\n            if (!pages[currentPage]) {\n                setError('Page \"'.concat(currentPage, '\" not found'));\n                const firstPage = Object.keys(pages).filter({\n                    \"LivePreview.useEffect\": (page)=>page.endsWith('.html')\n                }[\"LivePreview.useEffect\"])[0] || '';\n                if (!localPage && firstPage) {\n                    setLocalPage(firstPage);\n                    onPageChange === null || onPageChange === void 0 ? void 0 : onPageChange(firstPage);\n                }\n            } else if (!localPage) {\n                setLocalPage(currentPage);\n            }\n        }\n    }[\"LivePreview.useEffect\"], [\n        currentPage,\n        pages\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        ref: dropZoneRef,\n        onDragOver: handleDragOver,\n        onDragLeave: handleDragLeave,\n        onDrop: handleDrop,\n        className: \"relative h-full w-full rounded-lg border border-gray-200 bg-white shadow-sm overflow-hidden transition-all duration-300 \".concat(isDragOver ? 'border-purple-500 border-4' : ''),\n        children: [\n            isDragOver && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 bg-purple-500 bg-opacity-50 z-50 flex items-center justify-center\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"text-white text-2xl font-bold\",\n                    children: \"Drop your file here\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                    lineNumber: 732,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                lineNumber: 731,\n                columnNumber: 9\n            }, undefined),\n            isLoading && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 flex items-center justify-center bg-white/80 z-10 transition-opacity duration-200\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                    className: \"animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-purple-600\"\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                    lineNumber: 737,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                lineNumber: 736,\n                columnNumber: 9\n            }, undefined),\n            error && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                className: \"absolute inset-0 flex items-center justify-center bg-red-50 z-10 p-4\",\n                children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                    className: \"text-red-600 font-medium text-sm\",\n                    children: error\n                }, void 0, false, {\n                    fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                    lineNumber: 742,\n                    columnNumber: 11\n                }, undefined)\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                lineNumber: 741,\n                columnNumber: 9\n            }, undefined),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"iframe\", {\n                ref: iframeRef,\n                title: \"Live Preview\",\n                className: \"w-full h-full bg-white\",\n                sandbox: \"allow-scripts allow-same-origin allow-popups\",\n                onError: ()=>setError('Failed to load iframe content')\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n                lineNumber: 745,\n                columnNumber: 7\n            }, undefined)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\Abir\\\\Desktop\\\\lasttrynchlh - Copy (8)\\\\deepsite\\\\frontend\\\\src\\\\components\\\\LivePreview.tsx\",\n        lineNumber: 723,\n        columnNumber: 5\n    }, undefined);\n};\n_s(LivePreview, \"K20nyLPwtUiJqcesPnOkE1Tcfbo=\");\n_c = LivePreview;\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (LivePreview);\nvar _c;\n$RefreshReg$(_c, \"LivePreview\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9jb21wb25lbnRzL0xpdmVQcmV2aWV3LnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUNpRjtBQUMvQztBQVNsQyxNQUFNTyxjQUEwQztRQUFDLEVBQUVDLEtBQUssRUFBRUMsV0FBVyxFQUFFQyxZQUFZLEVBQUVDLFlBQVksRUFBRTs7SUFDakcsTUFBTSxDQUFDQyxXQUFXQyxhQUFhLEdBQUdWLCtDQUFRQSxDQUFTTTtJQUNuRCxNQUFNLENBQUNLLFdBQVdDLGFBQWEsR0FBR1osK0NBQVFBLENBQVU7SUFDcEQsTUFBTSxDQUFDYSxZQUFZQyxjQUFjLEdBQUdkLCtDQUFRQSxDQUFVO0lBQ3RELE1BQU0sQ0FBQ2UsT0FBT0MsU0FBUyxHQUFHaEIsK0NBQVFBLENBQWdCO0lBQ2xELE1BQU0sQ0FBQ2lCLGVBQWVDLGlCQUFpQixHQUFHbEIsK0NBQVFBLENBQWdCO0lBQ2xFLE1BQU1tQixZQUFZcEIsNkNBQU1BLENBQW9CO0lBQzVDLE1BQU1xQixjQUFjckIsNkNBQU1BLENBQWlCO0lBRTNDLGtCQUFrQjtJQUNsQixNQUFNc0IsWUFBWXBCLGtEQUFXQTs4Q0FBQyxDQUFDcUIsVUFBa0JDO1lBQy9DLElBQUk7Z0JBQ0YsSUFBSUMsVUFBVUYsU0FDWEcsT0FBTyxDQUFDLDhDQUE4QyxNQUN0REEsT0FBTyxDQUFDLGtCQUFrQixJQUMxQkEsT0FBTyxDQUFDLG9CQUFvQixJQUM1QkMsSUFBSTtnQkFFUCxJQUFJLENBQUNGLFNBQVMsTUFBTSxJQUFJRyxNQUFNO2dCQUU5QixJQUFJLENBQUNILFFBQVFJLFVBQVUsQ0FBQyxvQkFBb0JKLFVBQVUsc0JBQXNCQTtnQkFDNUUsSUFBSSxDQUFDQSxRQUFRSyxRQUFRLENBQUMsVUFBVUwsVUFBVSx3Q0FBd0NBLFVBQVU7Z0JBQzVGLElBQUksQ0FBQ0EsUUFBUUssUUFBUSxDQUFDLFdBQVc7b0JBQy9CTCxVQUFVQSxRQUFRQyxPQUFPLENBQ3ZCLFNBQ0E7Z0JBRUo7Z0JBQ0EsSUFB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QUlLLFdBQVU7MEJBQ2IsNEVBQUNDO29CQUFFRCxXQUFVOzhCQUFvQzdHOzs7Ozs7Ozs7OzswQkFHckQsOERBQUNtRTtnQkFDQ3NDLEtBQUtyRztnQkFDTDJHLE9BQU07Z0JBQ05GLFdBQVU7Z0JBQ1ZHLFNBQVE7Z0JBQ1JDLFNBQVMsSUFBTWhILFNBQVM7Ozs7Ozs7Ozs7OztBQUloQztHQXR1Qk1aO0tBQUFBO0FBd3VCTixpRUFBZUEsV0FBV0EsRUFBQyIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxBYmlyXFxEZXNrdG9wXFxsYXN0dHJ5bmNobGggLSBDb3B5ICg4KVxcZGVlcHNpdGVcXGZyb250ZW5kXFxzcmNcXGNvbXBvbmVudHNcXExpdmVQcmV2aWV3LnRzeCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VDYWxsYmFjaywgdXNlTWVtbyB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGRlYm91bmNlIH0gZnJvbSAnbG9kYXNoJztcblxuaW50ZXJmYWNlIExpdmVQcmV2aWV3UHJvcHMge1xuICBwYWdlczogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbiAgY3VycmVudFBhZ2U6IHN0cmluZztcbiAgb25GaWxlVXBsb2FkPzogKGZpbGU6IEZpbGUsIGNvbnRlbnQ6IHN0cmluZykgPT4gdm9pZDtcbiAgb25QYWdlQ2hhbmdlPzogKHBhZ2U6IHN0cmluZykgPT4gdm9pZDtcbn1cblxuY29uc3QgTGl2ZVByZXZpZXc6IFJlYWN0LkZDPExpdmVQcmV2aWV3UHJvcHM+ID0gKHsgcGFnZXMsIGN1cnJlbnRQYWdlLCBvblBhZ2VDaGFuZ2UsIG9uRmlsZVVwbG9hZCB9KSA9PiB7XG4gIGNvbnN0IFtsb2NhbFBhZ2UsIHNldExvY2FsUGFnZV0gPSB1c2VTdGF0ZTxzdHJpbmc+KGN1cnJlbnRQYWdlKTtcbiAgY29uc3QgW2lzTG9hZGluZywgc2V0SXNMb2FkaW5nXSA9IHVzZVN0YXRlPGJvb2xlYW4+KHRydWUpO1xuICBjb25zdCBbaXNEcmFnT3Zlciwgc2V0SXNEcmFnT3Zlcl0gPSB1c2VTdGF0ZTxib29sZWFuPihmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGU8c3RyaW5nIHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtsYXN0VmFsaWRIVE1MLCBzZXRMYXN0VmFsaWRIVE1MXSA9IHVzZVN0YXRlPHN0cmluZyB8IG51bGw+KG51bGwpO1xuICBjb25zdCBpZnJhbWVSZWYgPSB1c2VSZWY8SFRNTElGcmFtZUVsZW1lbnQ+KG51bGwpO1xuICBjb25zdCBkcm9wWm9uZVJlZiA9IHVzZVJlZjxIVE1MRGl2RWxlbWVudD4obnVsbCk7XG5cbiAgLy8gQ2xlYW4gSFRNTCBjb2RlXG4gIGNvbnN0IGNsZWFuQ29kZSA9IHVzZUNhbGxiYWNrKChodG1sQ29kZTogc3RyaW5nLCBwYWdlTmFtZTogc3RyaW5nKTogc3RyaW5nID0+IHtcbiAgICB0cnkge1xuICAgICAgbGV0IGNsZWFuZWQgPSBodG1sQ29kZVxuICAgICAgICAucmVwbGFjZSgvXltcXHNcXFNdKj8oPCFET0NUWVBFIGh0bWxbXFxzXFxTXSo/PFxcL2h0bWw+KS9pLCAnJDEnKVxuICAgICAgICAucmVwbGFjZSgvYGBgaHRtbFxcbnxgYGAvZywgJycpXG4gICAgICAgIC5yZXBsYWNlKC88IS0tW1xcc1xcU10qPy0tPi9nLCAnJylcbiAgICAgICAgLnRyaW0oKTtcbiAgXG4gICAgICBpZiAoIWNsZWFuZWQpIHRocm93IG5ldyBFcnJvcignSFRNTCBjb250ZW50IGlzIGVtcHR5IGFmdGVyIGNsZWFuaW5nJyk7XG4gIFxuICAgICAgaWYgKCFjbGVhbmVkLnN0YXJ0c1dpdGgoJzwhRE9DVFlQRSBodG1sPicpKSBjbGVhbmVkID0gJzwhRE9DVFlQRSBodG1sPlxcbicgKyBjbGVhbmVkO1xuICAgICAgaWYgKCFjbGVhbmVkLmluY2x1ZGVzKCc8aHRtbCcpKSBjbGVhbmVkID0gJzwhRE9DVFlQRSBodG1sPlxcbjxodG1sIGxhbmc9XCJlblwiPlxcbicgKyBjbGVhbmVkICsgJ1xcbjwvaHRtbD4nO1xuICAgICAgaWYgKCFjbGVhbmVkLmluY2x1ZGVzKCc8aGVhZD4nKSkge1xuICAgICAgICBjbGVhbmVkID0gY2xlYW5lZC5yZXBsYWNlKFxuICAgICAgICAgICc8aHRtbCcsXG4gICAgICAgICAgJzxodG1sIGxhbmc9XCJlblwiPlxcbjxoZWFkPlxcbjxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPlxcbjxtZXRhIG5hbWU9XCJ2aWV3cG9ydFwiIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MS4wXCI+XFxuPC9oZWFkPlxcbidcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghY2xlYW5lZC5pbmNsdWRlcygnPGJvZHk+JykpIHtcbiAgICAgICAgY2xlYW5lZCA9IGNsZWFuZWQucmVwbGFjZSgnPC9oZWFkPicsICc8L2hlYWQ+XFxuPGJvZHk+XFxuJykgKyAnXFxuPC9ib2R5Pic7XG4gICAgICB9XG4gIFxuICAgICAgaWYgKCFjbGVhbmVkLmVuZHNXaXRoKCc8L2h0bWw+JykpIGNsZWFuZWQgPSBjbGVhbmVkICsgJ1xcbjwvaHRtbD4nO1xuICBcbiAgICAgIHJldHVybiBjbGVhbmVkO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gY2xlYW5Db2RlOicsIGVycik7XG4gICAgICByZXR1cm4gbGFzdFZhbGlkSFRNTCB8fCBgXG4gICAgICAgIDwhRE9DVFlQRSBodG1sPlxuICAgICAgICA8aHRtbCBsYW5nPVwiZW5cIj5cbiAgICAgICAgICA8aGVhZD5cbiAgICAgICAgICAgIDxtZXRhIGNoYXJzZXQ9XCJVVEYtOFwiPlxuICAgICAgICAgICAgPG1ldGEgbmFtZT1cInZpZXdwb3J0XCIgY29udGVudD1cIndpZHRoPWRldmljZS13aWR0aCwgaW5pdGlhbC1zY2FsZT0xLjBcIj5cbiAgICAgICAgICA8L2hlYWQ+XG4gICAgICAgICAgPGJvZHk+XG4gICAgICAgICAgICA8aDE+RXJyZXVyIDogQ29udGVudSBIVE1MIGludmFsaWRlPC9oMT5cbiAgICAgICAgICA8L2JvZHk+XG4gICAgICAgIDwvaHRtbD5cbiAgICAgIGA7XG4gICAgfVxuICB9LCBbY3VycmVudFBhZ2UsbGFzdFZhbGlkSFRNTF0pO1xuXG5cblxuICAvLyBJbmplY3QgZHJhZy1hbmQtZHJvcCwgdGV4dCBlZGl0aW5nLCBhbmQgY29udHJvbCBmcmFtZSBzY3JpcHRcbiAgY29uc3QgaW5qZWN0RHJhZ0Ryb3BTY3JpcHQgPSAoKSA9PiBgXG4gICAgPHNjcmlwdD5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGVkaXRhYmxlRWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwLCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBzcGFuLCBkaXYsIHNlY3Rpb24sIGFydGljbGUsIGFzaWRlLCBmaWd1cmUsIGltZywgYnV0dG9uJyk7XG4gICAgICAgIGxldCBlbGVtZW50Q291bnRlciA9IGVkaXRhYmxlRWxlbWVudHMubGVuZ3RoO1xuXG4gICAgICAgIGVkaXRhYmxlRWxlbWVudHMuZm9yRWFjaCgoZWwsIGluZGV4KSA9PiB7XG4gICAgICAgICAgY29uc3QgaXNHb29nbGVNYXBTZWN0aW9uID0gZWwudGFnTmFtZSA9PT0gJ1NFQ1RJT04nICYmIGVsLnF1ZXJ5U2VsZWN0b3IoJyNtYXAnKTtcbiAgICAgICAgICBpZiAoKGVsLnRleHRDb250ZW50ICYmIGVsLnRleHRDb250ZW50LnRyaW0oKSkgfHwgZWwudGFnTmFtZSA9PT0gJ0lNRycgfHwgZWwudGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgaXNHb29nbGVNYXBTZWN0aW9uKSB7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RyYWdnYWJsZScsICd0cnVlJyk7XG4gICAgICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhZy1pZCcsICdkcmFnLScgKyBpbmRleCk7XG4gICAgICAgICAgICBlbC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICBlbC5zdHlsZS5jdXJzb3IgPSAnbW92ZSc7XG4gICAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gaXNHb29nbGVNYXBTZWN0aW9uID8gJ2Jsb2NrJyA6IChlbC50YWdOYW1lID09PSAnSU1HJyA/ICdpbmxpbmUtYmxvY2snIDogZWwuc3R5bGUuZGlzcGxheSB8fCAnYmxvY2snKTtcbiAgICAgICAgICAgIGlmIChpc0dvb2dsZU1hcFNlY3Rpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgbWFwRGl2ID0gZWwucXVlcnlTZWxlY3RvcignI21hcCcpO1xuICAgICAgICAgICAgICBpZiAobWFwRGl2KSB7XG4gICAgICAgICAgICAgICAgbWFwRGl2LnN0eWxlLndpZHRoID0gbWFwRGl2LnN0eWxlLndpZHRoIHx8ICcxMDAlJztcbiAgICAgICAgICAgICAgICBtYXBEaXYuc3R5bGUuaGVpZ2h0ID0gbWFwRGl2LnN0eWxlLmhlaWdodCB8fCAnNDAwcHgnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEFkZCBjbGljayBoYW5kbGVyIHRvIHNob3cgc2VsZWN0aW9uIGZyYW1lIGFuZCB0b29sYmFyXG4gICAgICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgICAgICAgICAgICAvLyBSZW1vdmUgZXhpc3RpbmcgZnJhbWUgYW5kIHRvb2xiYXJcbiAgICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdGcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3Rpb24tZnJhbWUnKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nRnJhbWUpIGV4aXN0aW5nRnJhbWUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVG9vbGJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jb250cm9sLXRvb2xiYXInKTtcbiAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVG9vbGJhcikgZXhpc3RpbmdUb29sYmFyLnJlbW92ZSgpO1xuXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSBzZWxlY3Rpb24gZnJhbWVcbiAgICAgICAgICAgICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICBjb25zdCBmcmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICBmcmFtZS5jbGFzc05hbWUgPSAnc2VsZWN0aW9uLWZyYW1lJztcbiAgICAgICAgICAgICAgZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICBmcmFtZS5zdHlsZS50b3AgPSAocmVjdC50b3AgLSAyICsgd2luZG93LnNjcm9sbFkpICsgJ3B4JztcbiAgICAgICAgICAgICAgZnJhbWUuc3R5bGUubGVmdCA9IChyZWN0LmxlZnQgLSAyICsgd2luZG93LnNjcm9sbFgpICsgJ3B4JztcbiAgICAgICAgICAgICAgZnJhbWUuc3R5bGUud2lkdGggPSAocmVjdC53aWR0aCArIDQpICsgJ3B4JztcbiAgICAgICAgICAgICAgZnJhbWUuc3R5bGUuaGVpZ2h0ID0gKHJlY3QuaGVpZ2h0ICsgNCkgKyAncHgnO1xuICAgICAgICAgICAgICBmcmFtZS5zdHlsZS5ib3JkZXIgPSAnMnB4IHNvbGlkICMwMDdiZmYnO1xuICAgICAgICAgICAgICBmcmFtZS5zdHlsZS56SW5kZXggPSAnOTk5JztcbiAgICAgICAgICAgICAgZnJhbWUuc2V0QXR0cmlidXRlKCdkYXRhLXRhcmdldC1pZCcsICdkcmFnLScgKyBpbmRleCk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZnJhbWUpO1xuXG4gICAgICAgICAgICAgIC8vIENyZWF0ZSB0b29sYmFyXG4gICAgICAgICAgICAgIGNvbnN0IHRvb2xiYXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgdG9vbGJhci5jbGFzc05hbWUgPSAnY29udHJvbC10b29sYmFyJztcbiAgICAgICAgICAgICAgdG9vbGJhci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgIHRvb2xiYXIuc3R5bGUudG9wID0gKHJlY3QudG9wIC0gNDAgKyB3aW5kb3cuc2Nyb2xsWSkgKyAncHgnO1xuICAgICAgICAgICAgICB0b29sYmFyLnN0eWxlLmxlZnQgPSAocmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDIgLSAxMDAgKyB3aW5kb3cuc2Nyb2xsWCkgKyAncHgnO1xuICAgICAgICAgICAgICB0b29sYmFyLnN0eWxlLmJhY2tncm91bmQgPSAnI2ZmZic7XG4gICAgICAgICAgICAgIHRvb2xiYXIuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjZGRkJztcbiAgICAgICAgICAgICAgdG9vbGJhci5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnOHB4JztcbiAgICAgICAgICAgICAgdG9vbGJhci5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgICAgICAgICAgIHRvb2xiYXIuc3R5bGUuYm94U2hhZG93ID0gJzAgMnB4IDVweCByZ2JhKDAsMCwwLDAuMSknO1xuICAgICAgICAgICAgICB0b29sYmFyLnN0eWxlLnpJbmRleCA9ICcxMDAwJztcbiAgICAgICAgICAgICAgdG9vbGJhci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgICAgICAgICAgICB0b29sYmFyLnN0eWxlLmdhcCA9ICc0cHgnO1xuXG4gICAgICAgICAgICAgIGNvbnN0IGljb25zID0gW1xuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdFZGl0JywgaWNvbjogJ+Kcj++4jycgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAnTG9jaycsIGljb246ICfwn5SSJyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdEdXBsaWNhdGUnLCBpY29uOiAn8J+TiycgfSxcbiAgICAgICAgICAgICAgICB7IHRpdGxlOiAnRGVsZXRlJywgaWNvbjogJ/Cfl5HvuI8nIH0sXG4gICAgICAgICAgICAgICAgeyB0aXRsZTogJ01vcmUnLCBpY29uOiAn4ouvJyB9LFxuICAgICAgICAgICAgICAgIHsgdGl0bGU6ICdBZGQgSW1hZ2UnLCBpY29uOiAn8J+WvO+4jycgfVxuICAgICAgICAgICAgICBdLm1hcChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBidG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICBidG4uaW5uZXJIVE1MID0gaXRlbS5pY29uO1xuICAgICAgICAgICAgICAgIGJ0bi50aXRsZSA9IGl0ZW0udGl0bGU7XG4gICAgICAgICAgICAgICAgYnRuLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgICAgICAgICBidG4uc3R5bGUuYmFja2dyb3VuZCA9ICdub25lJztcbiAgICAgICAgICAgICAgICBidG4uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgIGJ0bi5zdHlsZS5mb250U2l6ZSA9ICcxNnB4JztcbiAgICAgICAgICAgICAgICBidG4uc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgICAgICAgICAgICAgIGJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChlKSA9PiB7XG4gICAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0udGl0bGUgPT09ICdEZWxldGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVsLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICBmcmFtZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgdG9vbGJhci5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaXRlbS50aXRsZSA9PT0gJ0R1cGxpY2F0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2xvbmUgPSBlbC5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRDb3VudGVyKys7XG4gICAgICAgICAgICAgICAgICAgIGNsb25lLnNldEF0dHJpYnV0ZSgnZGF0YS1kcmFnLWlkJywgJ2RyYWctJyArIGVsZW1lbnRDb3VudGVyKTtcbiAgICAgICAgICAgICAgICAgICAgZWwucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoY2xvbmUsIGVsLm5leHRTaWJsaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgZnJhbWUucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRvb2xiYXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGl0ZW0udGl0bGUgPT09ICdBZGQgSW1hZ2UnKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiAndXBsb2FkLWltYWdlJyB9LCAnKicpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SFRNTCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdHlwZTogJ3VwZGF0ZS1odG1sJywgaHRtbDogbmV3SFRNTCB9LCAnKicpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBidG47XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIGljb25zLmZvckVhY2goYnRuID0+IHRvb2xiYXIuYXBwZW5kQ2hpbGQoYnRuKSk7XG4gICAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodG9vbGJhcik7XG5cbiAgICAgICAgICAgICAgLy8gSGlkZSBmcmFtZSBhbmQgdG9vbGJhciB3aGVuIGNsaWNraW5nIG91dHNpZGVcbiAgICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiBoaWRlRnJhbWUoZSkge1xuICAgICAgICAgICAgICAgIGlmICghZnJhbWUuY29udGFpbnMoZS50YXJnZXQpICYmICFlbC5jb250YWlucyhlLnRhcmdldCkgJiYgIXRvb2xiYXIuY29udGFpbnMoZS50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICBmcmFtZS5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgIHRvb2xiYXIucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhpZGVGcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9LCB7IG9uY2U6IHRydWUgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGxldCBkcmFnZ2VkRWxlbWVudCA9IG51bGw7XG4gICAgICAgIGxldCBkcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgbGV0IGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzUmVzaXppbmcgPSBmYWxzZTtcbiAgICAgICAgbGV0IHJlc2l6ZVRhcmdldCA9IG51bGw7XG4gICAgICAgIGxldCBzdGFydFgsIHN0YXJ0WSwgc3RhcnRXaWR0aCwgc3RhcnRIZWlnaHQ7XG4gICAgICAgIGxldCByZXNpemVFZGdlID0gJyc7XG5cbiAgICAgICAgLy8gRHJhZy1hbmQtZHJvcCBmdW5jdGlvbmFsaXR5XG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdTdGFydCA9IChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQuY2xvc2VzdCgnW2RyYWdnYWJsZT1cInRydWVcIl0nKTtcbiAgICAgICAgICBpZiAodGFyZ2V0ICYmICFpc1Jlc2l6aW5nICYmICgodGFyZ2V0LnRleHRDb250ZW50ICYmIHRhcmdldC50ZXh0Q29udGVudC50cmltKCkpIHx8IHRhcmdldC50YWdOYW1lID09PSAnSU1HJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgKHRhcmdldC50YWdOYW1lID09PSAnU0VDVElPTicgJiYgdGFyZ2V0LnF1ZXJ5U2VsZWN0b3IoJyNtYXAnKSkpKSB7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlbWVudCA9IHRhcmdldDtcbiAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoJ2RyYWdnaW5nJyk7XG4gICAgICAgICAgICBlLmRhdGFUcmFuc2Zlci5lZmZlY3RBbGxvd2VkID0gJ21vdmUnO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdGcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3Rpb24tZnJhbWUnKTtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0ZyYW1lKSBleGlzdGluZ0ZyYW1lLnJlbW92ZSgpO1xuICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdUb29sYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLmNvbnRyb2wtdG9vbGJhcicpO1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVG9vbGJhcikgZXhpc3RpbmdUb29sYmFyLnJlbW92ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBoYW5kbGVEcmFnT3ZlciA9IChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGUudGFyZ2V0LmNsb3Nlc3QoJ1tkcmFnZ2FibGU9XCJ0cnVlXCJdJyk7XG4gICAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50ICYmIHRhcmdldCAhPT0gZHJhZ2dlZEVsZW1lbnQgJiYgKCh0YXJnZXQudGV4dENvbnRlbnQgJiYgdGFyZ2V0LnRleHRDb250ZW50LnRyaW0oKSkgfHwgdGFyZ2V0LnRhZ05hbWUgPT09ICdJTUcnIHx8IHRhcmdldC50YWdOYW1lID09PSAnQlVUVE9OJyB8fCAodGFyZ2V0LnRhZ05hbWUgPT09ICdTRUNUSU9OJyAmJiB0YXJnZXQucXVlcnlTZWxlY3RvcignI21hcCcpKSkpIHtcbiAgICAgICAgICAgIGRyb3BUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LmFkZCgnZHJhZy1vdmVyJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGNvbnN0IGhhbmRsZURyYWdMZWF2ZSA9IChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQuY2xvc2VzdCgnW2RyYWdnYWJsZT1cInRydWVcIl0nKTtcbiAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICB0YXJnZXQuY2xhc3NMaXN0LnJlbW92ZSgnZHJhZy1vdmVyJyk7XG4gICAgICAgICAgICBkcm9wVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGFuZGxlRHJvcCA9IChlKSA9PiB7XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGRyb3BUYXJnZXQ7XG4gICAgICAgICAgaWYgKGRyYWdnZWRFbGVtZW50ICYmIHRhcmdldCAmJiBkcmFnZ2VkRWxlbWVudCAhPT0gdGFyZ2V0ICYmICgoZHJhZ2dlZEVsZW1lbnQudGV4dENvbnRlbnQgJiYgZHJhZ2dlZEVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB8fCBkcmFnZ2VkRWxlbWVudC50YWdOYW1lID09PSAnSU1HJyB8fCBkcmFnZ2VkRWxlbWVudC50YWdOYW1lID09PSAnQlVUVE9OJyB8fCAoZHJhZ2dlZEVsZW1lbnQudGFnTmFtZSA9PT0gJ1NFQ1RJT04nICYmIGRyYWdnZWRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYXAnKSkpKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnQgPSB0YXJnZXQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3QgaXNJbWFnZURyYWcgPSBkcmFnZ2VkRWxlbWVudC50YWdOYW1lID09PSAnSU1HJztcbiAgICAgICAgICAgICAgY29uc3QgaXNJbWFnZVRhcmdldCA9IHRhcmdldC50YWdOYW1lID09PSAnSU1HJztcbiAgICAgICAgICAgICAgY29uc3QgaXNCdXR0b25EcmFnID0gZHJhZ2dlZEVsZW1lbnQudGFnTmFtZSA9PT0gJ0JVVFRPTic7XG4gICAgICAgICAgICAgIGNvbnN0IGlzQnV0dG9uVGFyZ2V0ID0gdGFyZ2V0LnRhZ05hbWUgPT09ICdCVVRUT04nO1xuICAgICAgICAgICAgICBjb25zdCBpc0dvb2dsZU1hcFNlY3Rpb25EcmFnID0gZHJhZ2dlZEVsZW1lbnQudGFnTmFtZSA9PT0gJ1NFQ1RJT04nICYmIGRyYWdnZWRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJyNtYXAnKTtcbiAgICAgICAgICAgICAgY29uc3QgaXNHb29nbGVNYXBTZWN0aW9uVGFyZ2V0ID0gdGFyZ2V0LnRhZ05hbWUgPT09ICdTRUNUSU9OJyAmJiB0YXJnZXQucXVlcnlTZWxlY3RvcignI21hcCcpO1xuXG4gICAgICAgICAgICAgIGlmICgoaXNJbWFnZURyYWcgJiYgaXNJbWFnZVRhcmdldCkgfHwgKGlzQnV0dG9uRHJhZyAmJiBpc0J1dHRvblRhcmdldCkgfHwgKGlzR29vZ2xlTWFwU2VjdGlvbkRyYWcgJiYgaXNHb29nbGVNYXBTZWN0aW9uVGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBIVE1MID0gZHJhZ2dlZEVsZW1lbnQuaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBXaWR0aCA9IGRyYWdnZWRFbGVtZW50LnN0eWxlLndpZHRoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBIZWlnaHQgPSBkcmFnZ2VkRWxlbWVudC5zdHlsZS5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnQuaW5uZXJIVE1MID0gdGFyZ2V0LmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudC5zdHlsZS53aWR0aCA9IHRhcmdldC5zdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgICBkcmFnZ2VkRWxlbWVudC5zdHlsZS5oZWlnaHQgPSB0YXJnZXQuc3R5bGUuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHRhcmdldC5pbm5lckhUTUwgPSB0ZW1wSFRNTDtcbiAgICAgICAgICAgICAgICB0YXJnZXQuc3R5bGUud2lkdGggPSB0ZW1wV2lkdGg7XG4gICAgICAgICAgICAgICAgdGFyZ2V0LnN0eWxlLmhlaWdodCA9IHRlbXBIZWlnaHQ7XG5cbiAgICAgICAgICAgICAgICBpZiAoaXNHb29nbGVNYXBTZWN0aW9uRHJhZyB8fCBpc0dvb2dsZU1hcFNlY3Rpb25UYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgIFtkcmFnZ2VkRWxlbWVudCwgdGFyZ2V0XS5mb3JFYWNoKHNlY3Rpb24gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBEaXYgPSBzZWN0aW9uLnF1ZXJ5U2VsZWN0b3IoJyNtYXAnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hcERpdikge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IHNlY3Rpb24ucXVlcnlTZWxlY3Rvcignc2NyaXB0Om5vdChbc3JjXSknKTtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2NyaXB0KSBldmFsKHNjcmlwdC50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnQuaW5zZXJ0QmVmb3JlKGRyYWdnZWRFbGVtZW50LCB0YXJnZXQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nJyk7XG4gICAgICAgICAgICAgIHRhcmdldC5jbGFzc0xpc3QucmVtb3ZlKCdkcmFnLW92ZXInKTtcbiAgICAgICAgICAgICAgZHJhZ2dlZEVsZW1lbnQgPSBudWxsO1xuICAgICAgICAgICAgICBkcm9wVGFyZ2V0ID0gbnVsbDtcblxuICAgICAgICAgICAgICBjb25zdCBuZXdIVE1MID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgICAgd2luZG93LnBhcmVudC5wb3N0TWVzc2FnZSh7IHR5cGU6ICd1cGRhdGUtaHRtbCcsIGh0bWw6IG5ld0hUTUwgfSwgJyonKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgY29uc3QgaGFuZGxlRHJhZ0VuZCA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoZHJhZ2dlZEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGRyYWdnZWRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdnaW5nJyk7XG4gICAgICAgICAgICBkcmFnZ2VkRWxlbWVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkcm9wVGFyZ2V0KSB7XG4gICAgICAgICAgICBkcm9wVGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWctb3ZlcicpO1xuICAgICAgICAgICAgZHJvcFRhcmdldCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBBdHRhY2ggZHJhZy1hbmQtZHJvcCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ3N0YXJ0JywgaGFuZGxlRHJhZ1N0YXJ0KTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ292ZXInLCBoYW5kbGVEcmFnT3Zlcik7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2RyYWdsZWF2ZScsIGhhbmRsZURyYWdMZWF2ZSk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2Ryb3AnLCBoYW5kbGVEcm9wKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignZHJhZ2VuZCcsIGhhbmRsZURyYWdFbmQpO1xuXG4gICAgICAgIC8vIFRleHQgZWRpdGluZyBmb3IgYWxsIHRleHQtY29udGFpbmluZyBlbGVtZW50c1xuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudHMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdwLCBoMSwgaDIsIGgzLCBoNCwgaDUsIGg2LCBzcGFuLCBidXR0b24nKTtcbiAgICAgICAgdGV4dEVsZW1lbnRzLmZvckVhY2goZWwgPT4ge1xuICAgICAgICAgIGlmIChlbC50ZXh0Q29udGVudCAmJiBlbC50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgICAgIGVsLnN0eWxlLm92ZXJmbG93V3JhcCA9IGVsLnN0eWxlLm92ZXJmbG93V3JhcCB8fCAnYnJlYWstd29yZCc7XG4gICAgICAgICAgICBlbC5zdHlsZS53b3JkQnJlYWsgPSBlbC5zdHlsZS53b3JkQnJlYWsgfHwgJ2JyZWFrLXdvcmQnO1xuICAgICAgICAgICAgZWwuc3R5bGUud2hpdGVTcGFjZSA9IGVsLnN0eWxlLndoaXRlU3BhY2UgfHwgJ25vcm1hbCc7XG5cbiAgICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVsLmNsYXNzTGlzdC5jb250YWlucygnZWRpdGluZycpKSByZXR1cm47XG4gICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQoJ2VkaXRpbmcnKTtcblxuICAgICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSBlbC50ZXh0Q29udGVudDtcblxuICAgICAgICAgICAgICBjb25zdCB0ZXh0YXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAgIHRleHRhcmVhLnZhbHVlID0gb3JpZ2luYWxUZXh0O1xuXG4gICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndpZHRoID0gY29tcHV0ZWRTdHlsZS53aWR0aDtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4V2lkdGggPSBjb21wdXRlZFN0eWxlLm1heFdpZHRoID09PSAnbm9uZScgPyBjb21wdXRlZFN0eWxlLndpZHRoIDogY29tcHV0ZWRTdHlsZS5tYXhXaWR0aDtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5taW5IZWlnaHQgPSBjb21wdXRlZFN0eWxlLmhlaWdodDtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubWF4SGVpZ2h0ID0gY29tcHV0ZWRTdHlsZS5tYXhIZWlnaHQgPT09ICdub25lJyA/ICdub25lJyA6IGNvbXB1dGVkU3R5bGUubWF4SGVpZ2h0O1xuICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5wYWRkaW5nID0gY29tcHV0ZWRTdHlsZS5wYWRkaW5nO1xuICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5tYXJnaW4gPSBjb21wdXRlZFN0eWxlLm1hcmdpbjtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyID0gJzFweCBzb2xpZCAjY2NjJztcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuYm9yZGVyUmFkaXVzID0gY29tcHV0ZWRTdHlsZS5ib3JkZXJSYWRpdXM7XG4gICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmZvbnRGYW1pbHkgPSBjb21wdXRlZFN0eWxlLmZvbnRGYW1pbHk7XG4gICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmZvbnRTaXplID0gY29tcHV0ZWRTdHlsZS5mb250U2l6ZTtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuZm9udFdlaWdodCA9IGNvbXB1dGVkU3R5bGUuZm9udFdlaWdodDtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuY29sb3IgPSBjb21wdXRlZFN0eWxlLmNvbG9yO1xuICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb21wdXRlZFN0eWxlLmJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUubGluZUhlaWdodCA9IGNvbXB1dGVkU3R5bGUubGluZUhlaWdodDtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUudGV4dEFsaWduID0gY29tcHV0ZWRTdHlsZS50ZXh0QWxpZ247XG4gICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmJveFNpemluZyA9ICdib3JkZXItYm94JztcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUucmVzaXplID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUub3ZlcmZsb3dXcmFwID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS53b3JkQnJlYWsgPSAnYnJlYWstd29yZCc7XG4gICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcbiAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUub3ZlcmZsb3cgPSBjb21wdXRlZFN0eWxlLm92ZXJmbG93ID09PSAndmlzaWJsZScgPyAnYXV0bycgOiBjb21wdXRlZFN0eWxlLm92ZXJmbG93O1xuXG4gICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRleHRhcmVhKTtcbiAgICAgICAgICAgICAgdGV4dGFyZWEuZm9jdXMoKTtcblxuICAgICAgICAgICAgICB0ZXh0YXJlYS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFxcYFxcJHt0ZXh0YXJlYS5zY3JvbGxIZWlnaHR9cHhcXGA7XG5cbiAgICAgICAgICAgICAgdGV4dGFyZWEuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIHRleHRhcmVhLnN0eWxlLmhlaWdodCA9IFxcYFxcJHt0ZXh0YXJlYS5zY3JvbGxIZWlnaHR9cHhcXGA7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3VGV4dCA9IHRleHRhcmVhLnZhbHVlIHx8IG9yaWdpbmFsVGV4dDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZWwuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgZWwucmVtb3ZlQ2hpbGQoZWwuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsLnRleHRDb250ZW50ID0gbmV3VGV4dDtcbiAgICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdlZGl0aW5nJyk7XG5cbiAgICAgICAgICAgICAgICBlbC5zdHlsZS5vdmVyZmxvd1dyYXAgPSAnYnJlYWstd29yZCc7XG4gICAgICAgICAgICAgICAgZWwuc3R5bGUud29yZEJyZWFrID0gJ2JyZWFrLXdvcmQnO1xuICAgICAgICAgICAgICAgIGVsLnN0eWxlLndoaXRlU3BhY2UgPSAnbm9ybWFsJztcblxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0hUTUwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQub3V0ZXJIVE1MO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiAndXBkYXRlLWh0bWwnLCBodG1sOiBuZXdIVE1MIH0sICcqJyk7XG4gICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgIHRleHRhcmVhLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5rZXkgPT09ICdFbnRlcicgJiYgIWUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgIHRleHRhcmVhLmJsdXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGlmIHRoZSBtb3VzZSBpcyBuZWFyIGFuIGVkZ2VcbiAgICAgICAgY29uc3QgaXNOZWFyRWRnZSA9IChlbCwgY2xpZW50WCwgY2xpZW50WSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICBjb25zdCBlZGdlVGhyZXNob2xkID0gMTA7XG4gICAgICAgICAgY29uc3QgbmVhclJpZ2h0ID0gTWF0aC5hYnMoY2xpZW50WCAtIHJlY3QucmlnaHQpIDwgZWRnZVRocmVzaG9sZDtcbiAgICAgICAgICBjb25zdCBuZWFyQm90dG9tID0gTWF0aC5hYnMoY2xpZW50WSAtIHJlY3QuYm90dG9tKSA8IGVkZ2VUaHJlc2hvbGQ7XG4gICAgICAgICAgY29uc3QgbmVhckxlZnQgPSBNYXRoLmFicyhjbGllbnRYIC0gcmVjdC5sZWZ0KSA8IGVkZ2VUaHJlc2hvbGQ7XG4gICAgICAgICAgY29uc3QgbmVhclRvcCA9IE1hdGguYWJzKGNsaWVudFkgLSByZWN0LnRvcCkgPCBlZGdlVGhyZXNob2xkO1xuXG4gICAgICAgICAgaWYgKG5lYXJSaWdodCAmJiBuZWFyQm90dG9tKSByZXR1cm4gJ2JvdHRvbS1yaWdodCc7XG4gICAgICAgICAgaWYgKG5lYXJMZWZ0ICYmIG5lYXJCb3R0b20pIHJldHVybiAnYm90dG9tLWxlZnQnO1xuICAgICAgICAgIGlmIChuZWFyUmlnaHQgJiYgbmVhclRvcCkgcmV0dXJuICd0b3AtcmlnaHQnO1xuICAgICAgICAgIGlmIChuZWFyTGVmdCAmJiBuZWFyVG9wKSByZXR1cm4gJ3RvcC1sZWZ0JztcbiAgICAgICAgICBpZiAobmVhclJpZ2h0KSByZXR1cm4gJ3JpZ2h0JztcbiAgICAgICAgICBpZiAobmVhckxlZnQpIHJldHVybiAnbGVmdCc7XG4gICAgICAgICAgaWYgKG5lYXJCb3R0b20pIHJldHVybiAnYm90dG9tJztcbiAgICAgICAgICBpZiAobmVhclRvcCkgcmV0dXJuICd0b3AnO1xuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBFZGdlLWJhc2VkIHJlc2l6aW5nIG9uIHRoZSBzZWxlY3Rpb24gZnJhbWVcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgICBpZiAoaXNSZXNpemluZykgcmV0dXJuO1xuXG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2VsZWN0aW9uLWZyYW1lJyk7XG4gICAgICAgICAgaWYgKGZyYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBlZGdlID0gaXNOZWFyRWRnZShmcmFtZSwgZS5jbGllbnRYLCBlLmNsaWVudFkpO1xuICAgICAgICAgICAgaWYgKGVkZ2UgPT09ICdib3R0b20tcmlnaHQnIHx8IGVkZ2UgPT09ICd0b3AtbGVmdCcpIHtcbiAgICAgICAgICAgICAgZnJhbWUuc3R5bGUuY3Vyc29yID0gJ3NlLXJlc2l6ZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdib3R0b20tbGVmdCcgfHwgZWRnZSA9PT0gJ3RvcC1yaWdodCcpIHtcbiAgICAgICAgICAgICAgZnJhbWUuc3R5bGUuY3Vyc29yID0gJ3N3LXJlc2l6ZSc7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdsZWZ0JyB8fCBlZGdlID09PSAncmlnaHQnKSB7XG4gICAgICAgICAgICAgIGZyYW1lLnN0eWxlLmN1cnNvciA9ICdldy1yZXNpemUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlZGdlID09PSAndG9wJyB8fCBlZGdlID09PSAnYm90dG9tJykge1xuICAgICAgICAgICAgICBmcmFtZS5zdHlsZS5jdXJzb3IgPSAnbnMtcmVzaXplJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZyYW1lLnN0eWxlLmN1cnNvciA9ICdkZWZhdWx0JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIChlKSA9PiB7XG4gICAgICAgICAgY29uc3QgZnJhbWUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuc2VsZWN0aW9uLWZyYW1lJyk7XG4gICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignW2RhdGEtZHJhZy1pZD1cIicgKyAoZnJhbWU/LmdldEF0dHJpYnV0ZSgnZGF0YS10YXJnZXQtaWQnKSB8fCAnJykgKyAnXCJdJyk7XG4gICAgICAgICAgaWYgKGZyYW1lICYmIHRhcmdldCkge1xuICAgICAgICAgICAgY29uc3QgZWRnZSA9IGlzTmVhckVkZ2UoZnJhbWUsIGUuY2xpZW50WCwgZS5jbGllbnRZKTtcbiAgICAgICAgICAgIGlmIChlZGdlKSB7XG4gICAgICAgICAgICAgIGlzUmVzaXppbmcgPSB0cnVlO1xuICAgICAgICAgICAgICByZXNpemVUYXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgIHJlc2l6ZUVkZ2UgPSBlZGdlO1xuICAgICAgICAgICAgICBzdGFydFggPSBlLmNsaWVudFg7XG4gICAgICAgICAgICAgIHN0YXJ0WSA9IGUuY2xpZW50WTtcbiAgICAgICAgICAgICAgc3RhcnRXaWR0aCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS53aWR0aCkgfHwgdGFyZ2V0Lm9mZnNldFdpZHRoO1xuICAgICAgICAgICAgICBzdGFydEhlaWdodCA9IHBhcnNlSW50KGdldENvbXB1dGVkU3R5bGUodGFyZ2V0KS5oZWlnaHQpIHx8IHRhcmdldC5vZmZzZXRIZWlnaHQ7XG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIChlKSA9PiB7XG4gICAgICAgICAgaWYgKCFpc1Jlc2l6aW5nIHx8ICFyZXNpemVUYXJnZXQpIHJldHVybjtcblxuICAgICAgICAgIGNvbnN0IGR4ID0gZS5jbGllbnRYIC0gc3RhcnRYO1xuICAgICAgICAgIGNvbnN0IGR5ID0gZS5jbGllbnRZIC0gc3RhcnRZO1xuICAgICAgICAgIGxldCBuZXdXaWR0aCA9IHN0YXJ0V2lkdGg7XG4gICAgICAgICAgbGV0IG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0O1xuXG4gICAgICAgICAgaWYgKHJlc2l6ZUVkZ2UuaW5jbHVkZXMoJ3JpZ2h0JykpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gTWF0aC5tYXgoNTAsIHN0YXJ0V2lkdGggKyBkeCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChyZXNpemVFZGdlLmluY2x1ZGVzKCdsZWZ0JykpIHtcbiAgICAgICAgICAgIG5ld1dpZHRoID0gTWF0aC5tYXgoNTAsIHN0YXJ0V2lkdGggLSBkeCk7XG4gICAgICAgICAgICByZXNpemVUYXJnZXQuc3R5bGUubGVmdCA9IChwYXJzZUludChnZXRDb21wdXRlZFN0eWxlKHJlc2l6ZVRhcmdldCkubGVmdCkgfHwgMCkgKyAoc3RhcnRXaWR0aCAtIG5ld1dpZHRoKSArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXNpemVFZGdlLmluY2x1ZGVzKCdib3R0b20nKSkge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gTWF0aC5tYXgoNTAsIHN0YXJ0SGVpZ2h0ICsgZHkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVzaXplRWRnZS5pbmNsdWRlcygndG9wJykpIHtcbiAgICAgICAgICAgIG5ld0hlaWdodCA9IE1hdGgubWF4KDUwLCBzdGFydEhlaWdodCAtIGR5KTtcbiAgICAgICAgICAgIHJlc2l6ZVRhcmdldC5zdHlsZS50b3AgPSAocGFyc2VJbnQoZ2V0Q29tcHV0ZWRTdHlsZShyZXNpemVUYXJnZXQpLnRvcCkgfHwgMCkgKyAoc3RhcnRIZWlnaHQgLSBuZXdIZWlnaHQpICsgJ3B4JztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNpemVUYXJnZXQuc3R5bGUud2lkdGggPSBcXGBcXCR7bmV3V2lkdGh9cHhcXGA7XG4gICAgICAgICAgcmVzaXplVGFyZ2V0LnN0eWxlLmhlaWdodCA9IFxcYFxcJHtuZXdIZWlnaHR9cHhcXGA7XG5cbiAgICAgICAgICBjb25zdCBtYXBEaXYgPSByZXNpemVUYXJnZXQucXVlcnlTZWxlY3RvcignI21hcCcpO1xuICAgICAgICAgIGlmIChtYXBEaXYpIHtcbiAgICAgICAgICAgIG1hcERpdi5zdHlsZS53aWR0aCA9IFxcYFxcJHtuZXdXaWR0aH1weFxcYDtcbiAgICAgICAgICAgIG1hcERpdi5zdHlsZS5oZWlnaHQgPSBcXGBcXCR7bmV3SGVpZ2h0IC0gNTB9cHhcXGA7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGdvb2dsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgZ29vZ2xlLm1hcHMpIHtcbiAgICAgICAgICAgICAgZ29vZ2xlLm1hcHMuZXZlbnQudHJpZ2dlcihtYXBEaXYuX19nbWFwX18sICdyZXNpemUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIGZyYW1lIHNpemVcbiAgICAgICAgICBjb25zdCBmcmFtZSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5zZWxlY3Rpb24tZnJhbWUnKTtcbiAgICAgICAgICBpZiAoZnJhbWUpIHtcbiAgICAgICAgICAgIGZyYW1lLnN0eWxlLndpZHRoID0gKG5ld1dpZHRoICsgNCkgKyAncHgnO1xuICAgICAgICAgICAgZnJhbWUuc3R5bGUuaGVpZ2h0ID0gKG5ld0hlaWdodCArIDQpICsgJ3B4JztcbiAgICAgICAgICAgIGZyYW1lLnN0eWxlLmxlZnQgPSAocmVzaXplVGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSAyICsgd2luZG93LnNjcm9sbFgpICsgJ3B4JztcbiAgICAgICAgICAgIGZyYW1lLnN0eWxlLnRvcCA9IChyZXNpemVUYXJnZXQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wIC0gMiArIHdpbmRvdy5zY3JvbGxZKSArICdweCc7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xuICAgICAgICAgIGlmIChpc1Jlc2l6aW5nKSB7XG4gICAgICAgICAgICBpc1Jlc2l6aW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCBuZXdIVE1MID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm91dGVySFRNTDtcbiAgICAgICAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2UoeyB0eXBlOiAndXBkYXRlLWh0bWwnLCBodG1sOiBuZXdIVE1MIH0sICcqJyk7XG4gICAgICAgICAgICByZXNpemVUYXJnZXQuc3R5bGUuY3Vyc29yID0gJ21vdmUnO1xuICAgICAgICAgICAgcmVzaXplVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHJlc2l6ZUVkZ2UgPSAnJztcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgPC9zY3JpcHQ+XG4gICAgPHN0eWxlPlxuICAgICAgLmRyYWdnaW5nIHtcbiAgICAgICAgb3BhY2l0eTogMC41O1xuICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEuMik7XG4gICAgICAgIHRyYW5zaXRpb246IG9wYWNpdHkgMC4zcywgdHJhbnNmb3JtIDAuMnMgZWFzZS1pbi1vdXQ7XG4gICAgICAgIGJvcmRlcjogMnB4IGRhc2hlZCAjMDA3YmZmO1xuICAgICAgfVxuICAgICAgLmRyYWctb3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQ6ICNhNWQ2YTc7XG4gICAgICAgIGJvcmRlcjogMnB4IGRhc2hlZCAjNGNhZjUwO1xuICAgICAgfVxuICAgICAgW2RyYWdnYWJsZT1cInRydWVcIl0ge1xuICAgICAgICBwYWRkaW5nOiAwLjVyZW07XG4gICAgICAgIG1hcmdpbjogMC41cmVtO1xuICAgICAgICBjdXJzb3I6IGdyYWI7XG4gICAgICB9XG4gICAgICBbZHJhZ2dhYmxlPVwidHJ1ZVwiXS5kcmFnZ2luZyB7XG4gICAgICAgIGN1cnNvcjogZ3JhYmJpbmc7XG4gICAgICB9XG4gICAgICAuZWRpdGluZyB7XG4gICAgICAgIGJvcmRlcjogMXB4IGRhc2hlZCAjMDA3YmZmO1xuICAgICAgICBwYWRkaW5nOiA1cHg7XG4gICAgICB9XG4gICAgICBpbWcsIGRpdiwgc2VjdGlvbiwgYXJ0aWNsZSwgYXNpZGUsIGZpZ3VyZSwgYnV0dG9uIHtcbiAgICAgICAgbWluLXdpZHRoOiA1MHB4O1xuICAgICAgICBtaW4taGVpZ2h0OiA1MHB4O1xuICAgICAgfVxuICAgICAgc2VjdGlvbjpoYXMoI21hcCkge1xuICAgICAgICBib3JkZXI6IDFweCBzb2xpZCAjZGRkO1xuICAgICAgICBib3JkZXItcmFkaXVzOiA4cHg7XG4gICAgICAgIHBhZGRpbmc6IDEwcHg7XG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDVweCByZ2JhKDAsMCwwLDAuMSk7XG4gICAgICB9XG4gICAgICAuY29udHJvbC10b29sYmFyIGJ1dHRvbjpob3ZlciB7XG4gICAgICAgIGJhY2tncm91bmQ6ICNmMGYwZjA7XG4gICAgICAgIGJvcmRlci1yYWRpdXM6IDRweDtcbiAgICAgIH1cbiAgICAgIC5zZWxlY3Rpb24tZnJhbWUge1xuICAgICAgICBwb2ludGVyLWV2ZW50czogYXV0bztcbiAgICAgICAgYm94LXNpemluZzogYm9yZGVyLWJveDtcbiAgICAgIH1cbiAgICA8L3N0eWxlPlxuICBgO1xuXG4gIC8vIFByb2Nlc3MgSFRNTCB3aXRoIG5hdmlnYXRpb24gYW5kIGRyYWctYW5kLWRyb3Agc2NyaXB0c1xuICBjb25zdCBwcm9jZXNzSFRNTCA9IHVzZUNhbGxiYWNrKChodG1sOiBzdHJpbmcsIHBhZ2VMaXN0OiBzdHJpbmdbXSk6IHN0cmluZyA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKTtcbiAgICAgIGNvbnN0IGRvYyA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoaHRtbCwgJ3RleHQvaHRtbCcpO1xuXG4gICAgICBpZiAoIWRvYy5xdWVyeVNlbGVjdG9yKCdzY3JpcHRbZGF0YS1uYXZpZ2F0aW9uLWhhbmRsZXJdJykpIHtcbiAgICAgICAgY29uc3Qgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLW5hdmlnYXRpb24taGFuZGxlcicsICd0cnVlJyk7XG4gICAgICAgIHNjcmlwdC50ZXh0Q29udGVudCA9IGBcbiAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnYVtocmVmJD1cIi5odG1sXCJdJykuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgICAgICAgbGluay5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucGFyZW50LnBvc3RNZXNzYWdlKHsgdHlwZTogJ25hdmlnYXRpb24nLCBocmVmIH0sICcqJyk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIGA7XG4gICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZG9jLnF1ZXJ5U2VsZWN0b3IoJ3NjcmlwdFtkYXRhLWRyYWctZHJvcC1oYW5kbGVyXScpKSB7XG4gICAgICAgIGNvbnN0IGRyYWdEcm9wU2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICBkcmFnRHJvcFNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtZHJhZy1kcm9wLWhhbmRsZXInLCAndHJ1ZScpO1xuICAgICAgICBkcmFnRHJvcFNjcmlwdC50ZXh0Q29udGVudCA9IGluamVjdERyYWdEcm9wU2NyaXB0KCk7XG4gICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGRyYWdEcm9wU2NyaXB0KTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbmF2ID0gZG9jLnF1ZXJ5U2VsZWN0b3IoJ25hdicpO1xuICAgICAgaWYgKG5hdiAmJiBwYWdlTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHRoZW1lID0gbmF2LmdldEF0dHJpYnV0ZSgnZGF0YS10aGVtZScpIHx8ICdkaWdpdGFsJztcbiAgICAgICAgbmF2Lm91dGVySFRNTCA9IGdldE5hdkJhcihwYWdlTGlzdCwgY3VycmVudFBhZ2UsIHRoZW1lKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICc8IURPQ1RZUEUgaHRtbD4nICsgZG9jLmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwcm9jZXNzaW5nIEhUTUw6JywgZXJyKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBIVE1MIGNvbnRlbnQnKTtcbiAgICB9XG4gIH0sIFtjdXJyZW50UGFnZV0pO1xuXG4gIC8vIE5hdmlnYXRpb24gYmFyIGdlbmVyYXRvclxuICBmdW5jdGlvbiBnZXROYXZCYXIocGFnZXM6IHN0cmluZ1tdLCBjdXJyZW50UGFnZTogc3RyaW5nLCB0aGVtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgICBjb25zdCBjb2xvcnMgPSB7XG4gICAgICBuYXZCZzogJ3JnYmEoNDIsIDQyLCA0MiwgMC44KScsXG4gICAgICBuYXZMaW5rOiAnI2UwZTBlMCcsXG4gICAgICBuYXZBY3RpdmU6ICcjYmI4NmZjJyxcbiAgICB9O1xuICAgIHJldHVybiBgXG4gICAgICA8bmF2IHN0eWxlPVwicG9zaXRpb246IHN0aWNreTsgdG9wOiAwOyBiYWNrZ3JvdW5kOiAke2NvbG9ycy5uYXZCZ307IHBhZGRpbmc6IDFyZW0gMnJlbTsgdGV4dC1hbGlnbjogY2VudGVyOyBib3gtc2hhZG93OiAwIDJweCAxMHB4IHJnYmEoMCwgMCwgMCwgMC4xKTsgei1pbmRleDogMTAwMDtcIj5cbiAgICAgICAgJHtwYWdlcy5tYXAocGFnZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGFnZU5hbWUgPSBwYWdlLnJlcGxhY2UoJy5odG1sJywgJycpO1xuICAgICAgICAgIGNvbnN0IGlzQWN0aXZlID0gcGFnZSA9PT0gY3VycmVudFBhZ2U7XG4gICAgICAgICAgY29uc3QgYWN0aXZlU3R5bGUgPSBpc0FjdGl2ZSA/IGBjb2xvcjogJHtjb2xvcnMubmF2QWN0aXZlfTsgYm9yZGVyLWJvdHRvbTogMnB4IHNvbGlkICR7Y29sb3JzLm5hdkFjdGl2ZX07YCA6ICcnO1xuICAgICAgICAgIHJldHVybiBgPGEgaHJlZj1cIiR7cGFnZX1cIiBzdHlsZT1cImNvbG9yOiAke2NvbG9ycy5uYXZMaW5rfTsgdGV4dC1kZWNvcmF0aW9uOiBub25lOyBtYXJnaW46IDAgMS41cmVtOyBmb250LXdlaWdodDogNjAwOyAke2FjdGl2ZVN0eWxlfVwiPiR7cGFnZU5hbWV9PC9hPmA7XG4gICAgICAgIH0pLmpvaW4oJycpfVxuICAgICAgPC9uYXY+XG4gICAgYDtcbiAgfVxuXG4gIC8vIEhhbmRsZSBkcmFnLWFuZC1kcm9wIGV2ZW50cyBmb3IgZmlsZSB1cGxvYWRzXG4gIGNvbnN0IGhhbmRsZURyYWdPdmVyID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LkRyYWdFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzZXRJc0RyYWdPdmVyKHRydWUpO1xuICB9LCBbXSk7XG5cbiAgY29uc3QgaGFuZGxlRHJhZ0xlYXZlID0gdXNlQ2FsbGJhY2soKGU6IFJlYWN0LkRyYWdFdmVudDxIVE1MRGl2RWxlbWVudD4pID0+IHtcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBzZXRJc0RyYWdPdmVyKGZhbHNlKTtcbiAgfSwgW10pO1xuXG4gIGNvbnN0IGhhbmRsZURyb3AgPSB1c2VDYWxsYmFjayhhc3luYyAoZTogUmVhY3QuRHJhZ0V2ZW50PEhUTUxEaXZFbGVtZW50PikgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNldElzRHJhZ092ZXIoZmFsc2UpO1xuXG4gICAgY29uc3QgZmlsZXMgPSBlLmRhdGFUcmFuc2Zlci5maWxlcztcbiAgICBpZiAoZmlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgZmlsZSA9IGZpbGVzWzBdO1xuICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgIHJlYWRlci5vbmxvYWQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAmJiB0eXBlb2YgZXZlbnQudGFyZ2V0LnJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBpZiAob25GaWxlVXBsb2FkKSBvbkZpbGVVcGxvYWQoZmlsZSwgZXZlbnQudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICByZWFkZXIucmVhZEFzVGV4dChmaWxlKTtcbiAgICB9XG4gIH0sIFtvbkZpbGVVcGxvYWRdKTtcblxuICAvLyBVcGRhdGUgaWZyYW1lIGNvbnRlbnQgd2l0aCBkZWJvdW5jaW5nXG4gIGNvbnN0IHVwZGF0ZUlmcmFtZSA9IHVzZU1lbW8oXG4gICAgKCkgPT5cbiAgICAgIGRlYm91bmNlKCgpID0+IHtcbiAgICAgICAgY29uc3QgaWZyYW1lID0gaWZyYW1lUmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghaWZyYW1lIHx8ICFwYWdlc1tjdXJyZW50UGFnZV0pIHtcbiAgICAgICAgICBzZXRFcnJvcignUGFnZSBub3QgZm91bmQgb3IgaWZyYW1lIHVuYXZhaWxhYmxlJyk7XG4gICAgICAgICAgc2V0SXNMb2FkaW5nKGZhbHNlKTtcbiAgICAgICAgICBpZiAoaWZyYW1lICYmIGxhc3RWYWxpZEhUTUwpIGlmcmFtZS5zcmNkb2MgPSBsYXN0VmFsaWRIVE1MO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldElzTG9hZGluZyh0cnVlKTtcbiAgICAgICAgc2V0RXJyb3IobnVsbCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjbGVhbmVkSFRNTCA9IGNsZWFuQ29kZShwYWdlc1tjdXJyZW50UGFnZV0sIGN1cnJlbnRQYWdlKTtcbiAgICAgICAgICBjb25zdCBwYWdlTGlzdCA9IE9iamVjdC5rZXlzKHBhZ2VzKTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzZWRIVE1MID0gcHJvY2Vzc0hUTUwoY2xlYW5lZEhUTUwgKyBpbmplY3REcmFnRHJvcFNjcmlwdCgpLCBwYWdlTGlzdCk7XG4gICAgICAgICAgaWZyYW1lLnNyY2RvYyA9IHByb2Nlc3NlZEhUTUw7XG4gICAgICAgICAgc2V0TGFzdFZhbGlkSFRNTChwcm9jZXNzZWRIVE1MKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgc2V0RXJyb3IoJ0ZhaWxlZCB0byBsb2FkIHBhZ2UgY29udGVudDogJyArIChlcnIgaW5zdGFuY2VvZiBFcnJvciA/IGVyci5tZXNzYWdlIDogU3RyaW5nKGVycikpKTtcbiAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgIGlmIChpZnJhbWUgJiYgbGFzdFZhbGlkSFRNTCkgaWZyYW1lLnNyY2RvYyA9IGxhc3RWYWxpZEhUTUw7XG4gICAgICAgIH1cbiAgICAgIH0sIDMwMCksXG4gICAgW2N1cnJlbnRQYWdlLCBwYWdlcywgcHJvY2Vzc0hUTUwsIGNsZWFuQ29kZSwgbGFzdFZhbGlkSFRNTF1cbiAgKTtcblxuICAvLyBIYW5kbGUgaWZyYW1lIHVwZGF0ZXMgYW5kIG1lc3NhZ2VzXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXBkYXRlSWZyYW1lKCk7XG5cbiAgICBjb25zdCBpZnJhbWUgPSBpZnJhbWVSZWYuY3VycmVudDtcbiAgICBpZiAoIWlmcmFtZSkgcmV0dXJuO1xuXG4gICAgY29uc3QgaGFuZGxlTG9hZCA9ICgpID0+IHNldElzTG9hZGluZyhmYWxzZSk7XG4gICAgaWZyYW1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBoYW5kbGVMb2FkKTtcblxuICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSBhc3luYyAoZXZlbnQ6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50Lm9yaWdpbiAhPT0gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcpIHJldHVybjsgLy8gU2VjdXJpdHkgY2hlY2tcbiAgICAgIGlmIChldmVudC5kYXRhPy50eXBlID09PSAnbmF2aWdhdGlvbicgJiYgdHlwZW9mIGV2ZW50LmRhdGEuaHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHBhZ2VzW2V2ZW50LmRhdGEuaHJlZl0pIHtcbiAgICAgICAgICBzZXRMb2NhbFBhZ2UoZXZlbnQuZGF0YS5ocmVmKTtcbiAgICAgICAgICBvblBhZ2VDaGFuZ2U/LihldmVudC5kYXRhLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNldEVycm9yKGBQYWdlIFwiJHtldmVudC5kYXRhLmhyZWZ9XCIgbm90IGZvdW5kYCk7XG4gICAgICAgICAgY29uc3QgZmFsbGJhY2tQYWdlID0gT2JqZWN0LmtleXMocGFnZXMpLmZpbHRlcihwYWdlID0+IHBhZ2UuZW5kc1dpdGgoJy5odG1sJykpWzBdIHx8ICcnO1xuICAgICAgICAgIHNldExvY2FsUGFnZShmYWxsYmFja1BhZ2UpO1xuICAgICAgICAgIG9uUGFnZUNoYW5nZT8uKGZhbGxiYWNrUGFnZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gJ2ZpbGUtZHJvcCcpIHtcbiAgICAgICAgaWYgKG9uRmlsZVVwbG9hZCkge1xuICAgICAgICAgIGNvbnN0IGZpbGVDb250ZW50ID0gZXZlbnQuZGF0YS5maWxlQ29udGVudDtcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZSA9IGV2ZW50LmRhdGEuZmlsZU5hbWU7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWxlQ29udGVudCA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIGZpbGVOYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlKFtmaWxlQ29udGVudF0sIGZpbGVOYW1lLCB7IHR5cGU6ICd0ZXh0L2h0bWwnIH0pO1xuICAgICAgICAgICAgb25GaWxlVXBsb2FkKGZpbGUsIGZpbGVDb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXZlbnQuZGF0YT8udHlwZSA9PT0gJ3VwZGF0ZS1odG1sJykge1xuICAgICAgICBjb25zdCBuZXdIVE1MID0gZXZlbnQuZGF0YS5odG1sO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goJ2h0dHA6Ly9sb2NhbGhvc3Q6NTAwMC9hcGkvc2F2ZS1wYWdlJywge1xuICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICBoZWFkZXJzOiB7ICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcGFnZVBhdGg6IGN1cnJlbnRQYWdlLCBjb2RlOiBuZXdIVE1MIH0pLFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSFRUUCBlcnJvciEgc3RhdHVzOiAke3Jlc3BvbnNlLnN0YXR1c31gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICAgICAgICAgIHBhZ2VzW2N1cnJlbnRQYWdlXSA9IG5ld0hUTUw7IC8vIFVwZGF0ZSBsb2NhbCBzdGF0ZVxuICAgICAgICAgIHVwZGF0ZUlmcmFtZSgpOyAvLyBSZWZyZXNoIGlmcmFtZVxuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBzZXRFcnJvcihgRmFpbGVkIHRvIHNhdmUgdXBkYXRlZCBIVE1MOiAke2VyciBpbnN0YW5jZW9mIEVycm9yID8gZXJyLm1lc3NhZ2UgOiBTdHJpbmcoZXJyKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBpZnJhbWUucmVtb3ZlRXZlbnRMaXN0ZW5lcignbG9hZCcsIGhhbmRsZUxvYWQpO1xuICAgICAgdXBkYXRlSWZyYW1lLmNhbmNlbCgpO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCBoYW5kbGVNZXNzYWdlKTtcbiAgICB9O1xuICB9LCBbY3VycmVudFBhZ2UsIHBhZ2VzLCB1cGRhdGVJZnJhbWUsIG9uRmlsZVVwbG9hZF0pO1xuXG4gIC8vIFZhbGlkYXRlIGluaXRpYWwgcGFnZVxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICghcGFnZXNbY3VycmVudFBhZ2VdKSB7XG4gICAgICBzZXRFcnJvcihgUGFnZSBcIiR7Y3VycmVudFBhZ2V9XCIgbm90IGZvdW5kYCk7XG4gICAgICBjb25zdCBmaXJzdFBhZ2UgPSBPYmplY3Qua2V5cyhwYWdlcykuZmlsdGVyKHBhZ2UgPT4gcGFnZS5lbmRzV2l0aCgnLmh0bWwnKSlbMF0gfHwgJyc7XG4gICAgICBpZiAoIWxvY2FsUGFnZSAmJiBmaXJzdFBhZ2UpIHtcbiAgICAgICAgc2V0TG9jYWxQYWdlKGZpcnN0UGFnZSk7XG4gICAgICAgIG9uUGFnZUNoYW5nZT8uKGZpcnN0UGFnZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghbG9jYWxQYWdlKSB7XG4gICAgICBzZXRMb2NhbFBhZ2UoY3VycmVudFBhZ2UpO1xuICAgIH1cbiAgfSwgW2N1cnJlbnRQYWdlLCBwYWdlc10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgcmVmPXtkcm9wWm9uZVJlZn1cbiAgICAgIG9uRHJhZ092ZXI9e2hhbmRsZURyYWdPdmVyfVxuICAgICAgb25EcmFnTGVhdmU9e2hhbmRsZURyYWdMZWF2ZX1cbiAgICAgIG9uRHJvcD17aGFuZGxlRHJvcH1cbiAgICAgIGNsYXNzTmFtZT17YHJlbGF0aXZlIGgtZnVsbCB3LWZ1bGwgcm91bmRlZC1sZyBib3JkZXIgYm9yZGVyLWdyYXktMjAwIGJnLXdoaXRlIHNoYWRvdy1zbSBvdmVyZmxvdy1oaWRkZW4gdHJhbnNpdGlvbi1hbGwgZHVyYXRpb24tMzAwICR7aXNEcmFnT3ZlciA/ICdib3JkZXItcHVycGxlLTUwMCBib3JkZXItNCcgOiAnJ31gfVxuICAgID5cbiAgICAgIHtpc0RyYWdPdmVyICYmIChcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJhYnNvbHV0ZSBpbnNldC0wIGJnLXB1cnBsZS01MDAgYmctb3BhY2l0eS01MCB6LTUwIGZsZXggaXRlbXMtY2VudGVyIGp1c3RpZnktY2VudGVyXCI+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0ZXh0LXdoaXRlIHRleHQtMnhsIGZvbnQtYm9sZFwiPkRyb3AgeW91ciBmaWxlIGhlcmU8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgICApfVxuICAgICAge2lzTG9hZGluZyAmJiAoXG4gICAgICAgIDxkaXYgY2xhc3NOYW1lPVwiYWJzb2x1dGUgaW5zZXQtMCBmbGV4IGl0ZW1zLWNlbnRlciBqdXN0aWZ5LWNlbnRlciBiZy13aGl0ZS84MCB6LTEwIHRyYW5zaXRpb24tb3BhY2l0eSBkdXJhdGlvbi0yMDBcIj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFuaW1hdGUtc3BpbiByb3VuZGVkLWZ1bGwgaC0xMCB3LTEwIGJvcmRlci10LTIgYm9yZGVyLWItMiBib3JkZXItcHVycGxlLTYwMFwiPjwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICB7ZXJyb3IgJiYgKFxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImFic29sdXRlIGluc2V0LTAgZmxleCBpdGVtcy1jZW50ZXIganVzdGlmeS1jZW50ZXIgYmctcmVkLTUwIHotMTAgcC00XCI+XG4gICAgICAgICAgPHAgY2xhc3NOYW1lPVwidGV4dC1yZWQtNjAwIGZvbnQtbWVkaXVtIHRleHQtc21cIj57ZXJyb3J9PC9wPlxuICAgICAgICA8L2Rpdj5cbiAgICAgICl9XG4gICAgICA8aWZyYW1lXG4gICAgICAgIHJlZj17aWZyYW1lUmVmfVxuICAgICAgICB0aXRsZT1cIkxpdmUgUHJldmlld1wiXG4gICAgICAgIGNsYXNzTmFtZT1cInctZnVsbCBoLWZ1bGwgYmctd2hpdGVcIlxuICAgICAgICBzYW5kYm94PVwiYWxsb3ctc2NyaXB0cyBhbGxvdy1zYW1lLW9yaWdpbiBhbGxvdy1wb3B1cHNcIlxuICAgICAgICBvbkVycm9yPXsoKSA9PiBzZXRFcnJvcignRmFpbGVkIHRvIGxvYWQgaWZyYW1lIGNvbnRlbnQnKX1cbiAgICAgIC8+XG4gICAgPC9kaXY+XG4gICk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBMaXZlUHJldmlldzsiXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsInVzZUNhbGxiYWNrIiwidXNlTWVtbyIsImRlYm91bmNlIiwiTGl2ZVByZXZpZXciLCJwYWdlcyIsImN1cnJlbnRQYWdlIiwib25QYWdlQ2hhbmdlIiwib25GaWxlVXBsb2FkIiwibG9jYWxQYWdlIiwic2V0TG9jYWxQYWdlIiwiaXNMb2FkaW5nIiwic2V0SXNMb2FkaW5nIiwiaXNEcmFnT3ZlciIsInNldElzRHJhZ092ZXIiLCJlcnJvciIsInNldEVycm9yIiwibGFzdFZhbGlkSFRNTCIsInNldExhc3RWYWxpZEhUTUwiLCJpZnJhbWVSZWYiLCJkcm9wWm9uZVJlZiIsImNsZWFuQ29kZSIsImh0bWxDb2RlIiwicGFnZU5hbWUiLCJjbGVhbmVkIiwicmVwbGFjZSIsInRyaW0iLCJFcnJvciIsInN0YXJ0c1dpdGgiLCJpbmNsdWRlcyIsImVuZHNXaXRoIiwiZXJyIiwiY29uc29sZSIsImluamVjdERyYWdEcm9wU2NyaXB0IiwicHJvY2Vzc0hUTUwiLCJodG1sIiwicGFnZUxpc3QiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJkb2MiLCJwYXJzZUZyb21TdHJpbmciLCJxdWVyeVNlbGVjdG9yIiwic2NyaXB0IiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZSIsInRleHRDb250ZW50IiwiYm9keSIsImFwcGVuZENoaWxkIiwiZHJhZ0Ryb3BTY3JpcHQiLCJuYXYiLCJsZW5ndGgiLCJ0aGVtZSIsImdldEF0dHJpYnV0ZSIsIm91dGVySFRNTCIsImdldE5hdkJhciIsImRvY3VtZW50RWxlbWVudCIsImNvbG9ycyIsIm5hdkJnIiwibmF2TGluayIsIm5hdkFjdGl2ZSIsIm1hcCIsInBhZ2UiLCJpc0FjdGl2ZSIsImFjdGl2ZVN0eWxlIiwiam9pbiIsImhhbmRsZURyYWdPdmVyIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiaGFuZGxlRHJhZ0xlYXZlIiwiaGFuZGxlRHJvcCIsImZpbGVzIiwiZGF0YVRyYW5zZmVyIiwiZmlsZSIsInJlYWRlciIsIkZpbGVSZWFkZXIiLCJvbmxvYWQiLCJldmVudCIsInRhcmdldCIsInJlc3VsdCIsInJlYWRBc1RleHQiLCJ1cGRhdGVJZnJhbWUiLCJpZnJhbWUiLCJjdXJyZW50Iiwic3JjZG9jIiwiY2xlYW5lZEhUTUwiLCJPYmplY3QiLCJrZXlzIiwicHJvY2Vzc2VkSFRNTCIsIm1lc3NhZ2UiLCJTdHJpbmciLCJoYW5kbGVMb2FkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZU1lc3NhZ2UiLCJvcmlnaW4iLCJkYXRhIiwidHlwZSIsImhyZWYiLCJmYWxsYmFja1BhZ2UiLCJmaWx0ZXIiLCJmaWxlQ29udGVudCIsImZpbGVOYW1lIiwiRmlsZSIsIm5ld0hUTUwiLCJyZXNwb25zZSIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYWdlUGF0aCIsImNvZGUiLCJvayIsInN0YXR1cyIsImpzb24iLCJ3aW5kb3ciLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FuY2VsIiwiZmlyc3RQYWdlIiwiZGl2IiwicmVmIiwib25EcmFnT3ZlciIsIm9uRHJhZ0xlYXZlIiwib25Ecm9wIiwiY2xhc3NOYW1lIiwicCIsInRpdGxlIiwic2FuZGJveCIsIm9uRXJyb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/components/LivePreview.tsx\n"));

/***/ })

});